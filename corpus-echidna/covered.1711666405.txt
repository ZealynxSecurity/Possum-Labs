/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.0;
 5 |     | 
 6 |     | import "../utils/introspection/IERC165.sol";
 7 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/interfaces/IERC4906.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | import "./IERC721.sol";
  8 |     | 
  9 |     | /// @title EIP-721 Metadata Update Extension
 10 |     | interface IERC4906 is IERC165, IERC721 {
 11 |     |     /// @dev This event emits when the metadata of a token is changed.
 12 |     |     /// So that the third-party platforms such as NFT market could
 13 |     |     /// timely update the images and related attributes of the NFT.
 14 |     |     event MetadataUpdate(uint256 _tokenId);
 15 |     | 
 16 |     |     /// @dev This event emits when the metadata of a range of tokens is changed.
 17 |     |     /// So that the third-party platforms such as NFT market could
 18 |     |     /// timely update the images and related attributes of the NFTs.
 19 |     |     event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);
 20 |     | }
 21 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | interface IERC5267 {
  7 |     |     /**
  8 |     |      * @dev MAY be emitted to signal that the domain could have changed.
  9 |     |      */
 10 |     |     event EIP712DomainChanged();
 11 |     | 
 12 |     |     /**
 13 |     |      * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712
 14 |     |      * signature.
 15 |     |      */
 16 |     |     function eip712Domain()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             bytes1 fields,
 21 |     |             string memory name,
 22 |     |             string memory version,
 23 |     |             uint256 chainId,
 24 |     |             address verifyingContract,
 25 |     |             bytes32 salt,
 26 |     |             uint256[] memory extensions
 27 |     |         );
 28 |     | }
 29 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.0;
 5 |     | 
 6 |     | import "../token/ERC721/IERC721.sol";
 7 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 |     |     uint256 private constant _NOT_ENTERED = 1;
 35 |     |     uint256 private constant _ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     constructor() {
 40 |     |         _status = _NOT_ENTERED;
 41 |     |     }
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 45 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 46 |     |      * function is not supported. It is possible to prevent this from happening
 47 |     |      * by making the `nonReentrant` function external, and making it call a
 48 |     |      * `private` function that does the actual work.
 49 |     |      */
 50 |     |     modifier nonReentrant() {
 51 |     |         _nonReentrantBefore();
 52 |     |         _;
 53 | *   |         _nonReentrantAfter();
 54 |     |     }
 55 |     | 
 56 |     |     function _nonReentrantBefore() private {
 57 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 58 |     |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 59 |     | 
 60 |     |         // Any calls to nonReentrant after this point will fail
 61 |     |         _status = _ENTERED;
 62 |     |     }
 63 |     | 
 64 |     |     function _nonReentrantAfter() private {
 65 |     |         // By storing the original value once again, a refund is triggered (see
 66 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 67 |     |         _status = _NOT_ENTERED;
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 72 |     |      * `nonReentrant` function in the call stack.
 73 |     |      */
 74 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 75 |     |         return _status == _ENTERED;
 76 |     |     }
 77 |     | }
 78 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 |     |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 |     |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 |     |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 |     |         _approve(owner, spender, amount);
 139 |     |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 |     |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 |     |         _spendAllowance(from, spender, amount);
 161 |     |         _transfer(from, to, amount);
 162 |     |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 |     |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 |     |         require(from != address(0), "ERC20: transfer from the zero address");
 224 |     |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 |     |         uint256 fromBalance = _balances[from];
 229 |     |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 |     |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 |     |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 |     |         emit Transfer(from, to, amount);
 238 |     | 
 239 |     |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 |     |     function _mint(address account, uint256 amount) internal virtual {
 252 |     |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 |     |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 |     |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 |     |             _balances[account] += amount;
 260 |     |         }
 261 |     |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 |     |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 |     |     function _burn(address account, uint256 amount) internal virtual {
 278 |     |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 |     |         uint256 accountBalance = _balances[account];
 283 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 |     |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 |     |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 |     |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 |     |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 |     |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 |     |         require(owner != address(0), "ERC20: approve from the zero address");
 310 |     |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 |     |         _allowances[owner][spender] = amount;
 313 |     |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 |     |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 |     |         uint256 currentAllowance = allowance(owner, spender);
 326 |     |         if (currentAllowance != type(uint256).max) {
 327 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 |     |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC20.sol";
  7 |     | import "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Extension of {ERC20} that allows token holders to destroy both their own
 11 |     |  * tokens and those that they have an allowance for, in a way that can be
 12 |     |  * recognized off-chain (via event analysis).
 13 |     |  */
 14 |     | abstract contract ERC20Burnable is Context, ERC20 {
 15 |     |     /**
 16 |     |      * @dev Destroys `amount` tokens from the caller.
 17 |     |      *
 18 |     |      * See {ERC20-_burn}.
 19 |     |      */
 20 |     |     function burn(uint256 amount) public virtual {
 21 |     |         _burn(_msgSender(), amount);
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Destroys `amount` tokens from `account`, deducting from the caller's
 26 |     |      * allowance.
 27 |     |      *
 28 |     |      * See {ERC20-_burn} and {ERC20-allowance}.
 29 |     |      *
 30 |     |      * Requirements:
 31 |     |      *
 32 |     |      * - the caller must have allowance for ``accounts``'s tokens of at least
 33 |     |      * `amount`.
 34 |     |      */
 35 |     |     function burnFrom(address account, uint256 amount) public virtual {
 36 |     |         _spendAllowance(account, _msgSender(), amount);
 37 |     |         _burn(account, amount);
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC20Permit.sol";
  7 |     | import "../ERC20.sol";
  8 |     | import "../../../utils/cryptography/ECDSA.sol";
  9 |     | import "../../../utils/cryptography/EIP712.sol";
 10 |     | import "../../../utils/Counters.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 14 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 15 |     |  *
 16 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 17 |     |  * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't
 18 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 19 |     |  *
 20 |     |  * _Available since v3.4._
 21 |     |  */
 22 |     | abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
 23 |     |     using Counters for Counters.Counter;
 24 |     | 
 25 |     |     mapping(address => Counters.Counter) private _nonces;
 26 |     | 
 27 |     |     // solhint-disable-next-line var-name-mixedcase
 28 |     |     bytes32 private constant _PERMIT_TYPEHASH =
 29 |     |         keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
 30 |     |     /**
 31 |     |      * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.
 32 |     |      * However, to ensure consistency with the upgradeable transpiler, we will continue
 33 |     |      * to reserve a slot.
 34 |     |      * @custom:oz-renamed-from _PERMIT_TYPEHASH
 35 |     |      */
 36 |     |     // solhint-disable-next-line var-name-mixedcase
 37 |     |     bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;
 38 |     | 
 39 |     |     /**
 40 |     |      * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `"1"`.
 41 |     |      *
 42 |     |      * It's a good idea to use the same `name` that is defined as the ERC20 token name.
 43 |     |      */
 44 |     |     constructor(string memory name) EIP712(name, "1") {}
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev See {IERC20Permit-permit}.
 48 |     |      */
 49 |     |     function permit(
 50 |     |         address owner,
 51 |     |         address spender,
 52 |     |         uint256 value,
 53 |     |         uint256 deadline,
 54 |     |         uint8 v,
 55 |     |         bytes32 r,
 56 |     |         bytes32 s
 57 |     |     ) public virtual override {
 58 |     |         require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
 59 |     | 
 60 |     |         bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));
 61 |     | 
 62 |     |         bytes32 hash = _hashTypedDataV4(structHash);
 63 |     | 
 64 |     |         address signer = ECDSA.recover(hash, v, r, s);
 65 |     |         require(signer == owner, "ERC20Permit: invalid signature");
 66 |     | 
 67 |     |         _approve(owner, spender, value);
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev See {IERC20Permit-nonces}.
 72 |     |      */
 73 |     |     function nonces(address owner) public view virtual override returns (uint256) {
 74 |     |         return _nonces[owner].current();
 75 |     |     }
 76 |     | 
 77 |     |     /**
 78 |     |      * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.
 79 |     |      */
 80 |     |     // solhint-disable-next-line func-name-mixedcase
 81 |     |     function DOMAIN_SEPARATOR() external view override returns (bytes32) {
 82 |     |         return _domainSeparatorV4();
 83 |     |     }
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev "Consume a nonce": return the current value and increment.
 87 |     |      *
 88 |     |      * _Available since v4.1._
 89 |     |      */
 90 |     |     function _useNonce(address owner) internal virtual returns (uint256 current) {
 91 |     |         Counters.Counter storage nonce = _nonces[owner];
 92 |     |         current = nonce.current();
 93 |     |         nonce.increment();
 94 |     |     }
 95 |     | }
 96 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  */
 14 |     | interface IERC20Permit {
 15 |     |     /**
 16 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 17 |     |      * given ``owner``'s signed approval.
 18 |     |      *
 19 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 20 |     |      * ordering also apply here.
 21 |     |      *
 22 |     |      * Emits an {Approval} event.
 23 |     |      *
 24 |     |      * Requirements:
 25 |     |      *
 26 |     |      * - `spender` cannot be the zero address.
 27 |     |      * - `deadline` must be a timestamp in the future.
 28 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 29 |     |      * over the EIP712-formatted function arguments.
 30 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 31 |     |      *
 32 |     |      * For more information on the signature format, see the
 33 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 34 |     |      * section].
 35 |     |      */
 36 |     |     function permit(
 37 |     |         address owner,
 38 |     |         address spender,
 39 |     |         uint256 value,
 40 |     |         uint256 deadline,
 41 |     |         uint8 v,
 42 |     |         bytes32 r,
 43 |     |         bytes32 s
 44 |     |     ) external;
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Returns the current nonce for `owner`. This value must be
 48 |     |      * included whenever a signature is generated for {permit}.
 49 |     |      *
 50 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 51 |     |      * prevents a signature from being used multiple times.
 52 |     |      */
 53 |     |     function nonces(address owner) external view returns (uint256);
 54 |     | 
 55 |     |     /**
 56 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 57 |     |      */
 58 |     |     // solhint-disable-next-line func-name-mixedcase
 59 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 60 |     | }
 61 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  35 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to
  80 |     |      * 0 before setting it to a non-zero value.
  81 |     |      */
  82 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20Permit token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 |     |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 |     |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 |     |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC721.sol";
   7 |     | import "./IERC721Receiver.sol";
   8 |     | import "./extensions/IERC721Metadata.sol";
   9 |     | import "../../utils/Address.sol";
  10 |     | import "../../utils/Context.sol";
  11 |     | import "../../utils/Strings.sol";
  12 |     | import "../../utils/introspection/ERC165.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
  16 |     |  * the Metadata extension, but not including the Enumerable extension, which is available separately as
  17 |     |  * {ERC721Enumerable}.
  18 |     |  */
  19 |     | contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
  20 |     |     using Address for address;
  21 |     |     using Strings for uint256;
  22 |     | 
  23 |     |     // Token name
  24 |     |     string private _name;
  25 |     | 
  26 |     |     // Token symbol
  27 |     |     string private _symbol;
  28 |     | 
  29 |     |     // Mapping from token ID to owner address
  30 |     |     mapping(uint256 => address) private _owners;
  31 |     | 
  32 |     |     // Mapping owner address to token count
  33 |     |     mapping(address => uint256) private _balances;
  34 |     | 
  35 |     |     // Mapping from token ID to approved address
  36 |     |     mapping(uint256 => address) private _tokenApprovals;
  37 |     | 
  38 |     |     // Mapping from owner to operator approvals
  39 |     |     mapping(address => mapping(address => bool)) private _operatorApprovals;
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
  43 |     |      */
  44 |     |     constructor(string memory name_, string memory symbol_) {
  45 |     |         _name = name_;
  46 |     |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC165-supportsInterface}.
  51 |     |      */
  52 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  53 |     |         return
  54 |     |             interfaceId == type(IERC721).interfaceId ||
  55 |     |             interfaceId == type(IERC721Metadata).interfaceId ||
  56 |     |             super.supportsInterface(interfaceId);
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev See {IERC721-balanceOf}.
  61 |     |      */
  62 |     |     function balanceOf(address owner) public view virtual override returns (uint256) {
  63 |     |         require(owner != address(0), "ERC721: address zero is not a valid owner");
  64 |     |         return _balances[owner];
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev See {IERC721-ownerOf}.
  69 |     |      */
  70 |     |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
  71 |     |         address owner = _ownerOf(tokenId);
  72 |     |         require(owner != address(0), "ERC721: invalid token ID");
  73 |     |         return owner;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev See {IERC721Metadata-name}.
  78 |     |      */
  79 |     |     function name() public view virtual override returns (string memory) {
  80 |     |         return _name;
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev See {IERC721Metadata-symbol}.
  85 |     |      */
  86 |     |     function symbol() public view virtual override returns (string memory) {
  87 |     |         return _symbol;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev See {IERC721Metadata-tokenURI}.
  92 |     |      */
  93 |     |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
  94 |     |         _requireMinted(tokenId);
  95 |     | 
  96 |     |         string memory baseURI = _baseURI();
  97 |     |         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
 102 |     |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
 103 |     |      * by default, can be overridden in child contracts.
 104 |     |      */
 105 |     |     function _baseURI() internal view virtual returns (string memory) {
 106 |     |         return "";
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev See {IERC721-approve}.
 111 |     |      */
 112 |     |     function approve(address to, uint256 tokenId) public virtual override {
 113 |     |         address owner = ERC721.ownerOf(tokenId);
 114 |     |         require(to != owner, "ERC721: approval to current owner");
 115 |     | 
 116 |     |         require(
 117 |     |             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
 118 |     |             "ERC721: approve caller is not token owner or approved for all"
 119 |     |         );
 120 |     | 
 121 |     |         _approve(to, tokenId);
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev See {IERC721-getApproved}.
 126 |     |      */
 127 |     |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
 128 |     |         _requireMinted(tokenId);
 129 |     | 
 130 |     |         return _tokenApprovals[tokenId];
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev See {IERC721-setApprovalForAll}.
 135 |     |      */
 136 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
 137 |     |         _setApprovalForAll(_msgSender(), operator, approved);
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @dev See {IERC721-isApprovedForAll}.
 142 |     |      */
 143 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
 144 |     |         return _operatorApprovals[owner][operator];
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev See {IERC721-transferFrom}.
 149 |     |      */
 150 |     |     function transferFrom(address from, address to, uint256 tokenId) public virtual override {
 151 |     |         //solhint-disable-next-line max-line-length
 152 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 153 |     | 
 154 |     |         _transfer(from, to, tokenId);
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev See {IERC721-safeTransferFrom}.
 159 |     |      */
 160 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
 161 |     |         safeTransferFrom(from, to, tokenId, "");
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev See {IERC721-safeTransferFrom}.
 166 |     |      */
 167 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {
 168 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 169 |     |         _safeTransfer(from, to, tokenId, data);
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
 174 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
 175 |     |      *
 176 |     |      * `data` is additional data, it has no specified format and it is sent in call to `to`.
 177 |     |      *
 178 |     |      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
 179 |     |      * implement alternative mechanisms to perform token transfer, such as signature-based.
 180 |     |      *
 181 |     |      * Requirements:
 182 |     |      *
 183 |     |      * - `from` cannot be the zero address.
 184 |     |      * - `to` cannot be the zero address.
 185 |     |      * - `tokenId` token must exist and be owned by `from`.
 186 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 187 |     |      *
 188 |     |      * Emits a {Transfer} event.
 189 |     |      */
 190 |     |     function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
 191 |     |         _transfer(from, to, tokenId);
 192 |     |         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
 197 |     |      */
 198 |     |     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
 199 |     |         return _owners[tokenId];
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev Returns whether `tokenId` exists.
 204 |     |      *
 205 |     |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
 206 |     |      *
 207 |     |      * Tokens start existing when they are minted (`_mint`),
 208 |     |      * and stop existing when they are burned (`_burn`).
 209 |     |      */
 210 |     |     function _exists(uint256 tokenId) internal view virtual returns (bool) {
 211 |     |         return _ownerOf(tokenId) != address(0);
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev Returns whether `spender` is allowed to manage `tokenId`.
 216 |     |      *
 217 |     |      * Requirements:
 218 |     |      *
 219 |     |      * - `tokenId` must exist.
 220 |     |      */
 221 |     |     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
 222 |     |         address owner = ERC721.ownerOf(tokenId);
 223 |     |         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
 224 |     |     }
 225 |     | 
 226 |     |     /**
 227 |     |      * @dev Safely mints `tokenId` and transfers it to `to`.
 228 |     |      *
 229 |     |      * Requirements:
 230 |     |      *
 231 |     |      * - `tokenId` must not exist.
 232 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 233 |     |      *
 234 |     |      * Emits a {Transfer} event.
 235 |     |      */
 236 |     |     function _safeMint(address to, uint256 tokenId) internal virtual {
 237 |     |         _safeMint(to, tokenId, "");
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
 242 |     |      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
 243 |     |      */
 244 |     |     function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {
 245 |     |         _mint(to, tokenId);
 246 |     |         require(
 247 |     |             _checkOnERC721Received(address(0), to, tokenId, data),
 248 |     |             "ERC721: transfer to non ERC721Receiver implementer"
 249 |     |         );
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev Mints `tokenId` and transfers it to `to`.
 254 |     |      *
 255 |     |      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
 256 |     |      *
 257 |     |      * Requirements:
 258 |     |      *
 259 |     |      * - `tokenId` must not exist.
 260 |     |      * - `to` cannot be the zero address.
 261 |     |      *
 262 |     |      * Emits a {Transfer} event.
 263 |     |      */
 264 |     |     function _mint(address to, uint256 tokenId) internal virtual {
 265 |     |         require(to != address(0), "ERC721: mint to the zero address");
 266 |     |         require(!_exists(tokenId), "ERC721: token already minted");
 267 |     | 
 268 |     |         _beforeTokenTransfer(address(0), to, tokenId, 1);
 269 |     | 
 270 |     |         // Check that tokenId was not minted by `_beforeTokenTransfer` hook
 271 |     |         require(!_exists(tokenId), "ERC721: token already minted");
 272 |     | 
 273 |     |         unchecked {
 274 |     |             // Will not overflow unless all 2**256 token ids are minted to the same owner.
 275 |     |             // Given that tokens are minted one by one, it is impossible in practice that
 276 |     |             // this ever happens. Might change if we allow batch minting.
 277 |     |             // The ERC fails to describe this case.
 278 |     |             _balances[to] += 1;
 279 |     |         }
 280 |     | 
 281 |     |         _owners[tokenId] = to;
 282 |     | 
 283 |     |         emit Transfer(address(0), to, tokenId);
 284 |     | 
 285 |     |         _afterTokenTransfer(address(0), to, tokenId, 1);
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * @dev Destroys `tokenId`.
 290 |     |      * The approval is cleared when the token is burned.
 291 |     |      * This is an internal function that does not check if the sender is authorized to operate on the token.
 292 |     |      *
 293 |     |      * Requirements:
 294 |     |      *
 295 |     |      * - `tokenId` must exist.
 296 |     |      *
 297 |     |      * Emits a {Transfer} event.
 298 |     |      */
 299 |     |     function _burn(uint256 tokenId) internal virtual {
 300 |     |         address owner = ERC721.ownerOf(tokenId);
 301 |     | 
 302 |     |         _beforeTokenTransfer(owner, address(0), tokenId, 1);
 303 |     | 
 304 |     |         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook
 305 |     |         owner = ERC721.ownerOf(tokenId);
 306 |     | 
 307 |     |         // Clear approvals
 308 |     |         delete _tokenApprovals[tokenId];
 309 |     | 
 310 |     |         unchecked {
 311 |     |             // Cannot overflow, as that would require more tokens to be burned/transferred
 312 |     |             // out than the owner initially received through minting and transferring in.
 313 |     |             _balances[owner] -= 1;
 314 |     |         }
 315 |     |         delete _owners[tokenId];
 316 |     | 
 317 |     |         emit Transfer(owner, address(0), tokenId);
 318 |     | 
 319 |     |         _afterTokenTransfer(owner, address(0), tokenId, 1);
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Transfers `tokenId` from `from` to `to`.
 324 |     |      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
 325 |     |      *
 326 |     |      * Requirements:
 327 |     |      *
 328 |     |      * - `to` cannot be the zero address.
 329 |     |      * - `tokenId` token must be owned by `from`.
 330 |     |      *
 331 |     |      * Emits a {Transfer} event.
 332 |     |      */
 333 |     |     function _transfer(address from, address to, uint256 tokenId) internal virtual {
 334 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 335 |     |         require(to != address(0), "ERC721: transfer to the zero address");
 336 |     | 
 337 |     |         _beforeTokenTransfer(from, to, tokenId, 1);
 338 |     | 
 339 |     |         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
 340 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 341 |     | 
 342 |     |         // Clear approvals from the previous owner
 343 |     |         delete _tokenApprovals[tokenId];
 344 |     | 
 345 |     |         unchecked {
 346 |     |             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
 347 |     |             // `from`'s balance is the number of token held, which is at least one before the current
 348 |     |             // transfer.
 349 |     |             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
 350 |     |             // all 2**256 token ids to be minted, which in practice is impossible.
 351 |     |             _balances[from] -= 1;
 352 |     |             _balances[to] += 1;
 353 |     |         }
 354 |     |         _owners[tokenId] = to;
 355 |     | 
 356 |     |         emit Transfer(from, to, tokenId);
 357 |     | 
 358 |     |         _afterTokenTransfer(from, to, tokenId, 1);
 359 |     |     }
 360 |     | 
 361 |     |     /**
 362 |     |      * @dev Approve `to` to operate on `tokenId`
 363 |     |      *
 364 |     |      * Emits an {Approval} event.
 365 |     |      */
 366 |     |     function _approve(address to, uint256 tokenId) internal virtual {
 367 |     |         _tokenApprovals[tokenId] = to;
 368 |     |         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
 369 |     |     }
 370 |     | 
 371 |     |     /**
 372 |     |      * @dev Approve `operator` to operate on all of `owner` tokens
 373 |     |      *
 374 |     |      * Emits an {ApprovalForAll} event.
 375 |     |      */
 376 |     |     function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
 377 |     |         require(owner != operator, "ERC721: approve to caller");
 378 |     |         _operatorApprovals[owner][operator] = approved;
 379 |     |         emit ApprovalForAll(owner, operator, approved);
 380 |     |     }
 381 |     | 
 382 |     |     /**
 383 |     |      * @dev Reverts if the `tokenId` has not been minted yet.
 384 |     |      */
 385 |     |     function _requireMinted(uint256 tokenId) internal view virtual {
 386 |     |         require(_exists(tokenId), "ERC721: invalid token ID");
 387 |     |     }
 388 |     | 
 389 |     |     /**
 390 |     |      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
 391 |     |      * The call is not executed if the target address is not a contract.
 392 |     |      *
 393 |     |      * @param from address representing the previous owner of the given token ID
 394 |     |      * @param to target address that will receive the tokens
 395 |     |      * @param tokenId uint256 ID of the token to be transferred
 396 |     |      * @param data bytes optional data to send along with the call
 397 |     |      * @return bool whether the call correctly returned the expected magic value
 398 |     |      */
 399 |     |     function _checkOnERC721Received(
 400 |     |         address from,
 401 |     |         address to,
 402 |     |         uint256 tokenId,
 403 |     |         bytes memory data
 404 |     |     ) private returns (bool) {
 405 |     |         if (to.isContract()) {
 406 |     |             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
 407 |     |                 return retval == IERC721Receiver.onERC721Received.selector;
 408 |     |             } catch (bytes memory reason) {
 409 |     |                 if (reason.length == 0) {
 410 |     |                     revert("ERC721: transfer to non ERC721Receiver implementer");
 411 |     |                 } else {
 412 |     |                     /// @solidity memory-safe-assembly
 413 |     |                     assembly {
 414 |     |                         revert(add(32, reason), mload(reason))
 415 |     |                     }
 416 |     |                 }
 417 |     |             }
 418 |     |         } else {
 419 |     |             return true;
 420 |     |         }
 421 |     |     }
 422 |     | 
 423 |     |     /**
 424 |     |      * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 425 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 426 |     |      *
 427 |     |      * Calling conditions:
 428 |     |      *
 429 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
 430 |     |      * - When `from` is zero, the tokens will be minted for `to`.
 431 |     |      * - When `to` is zero, ``from``'s tokens will be burned.
 432 |     |      * - `from` and `to` are never both zero.
 433 |     |      * - `batchSize` is non-zero.
 434 |     |      *
 435 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 436 |     |      */
 437 |     |     function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
 438 |     | 
 439 |     |     /**
 440 |     |      * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 441 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 442 |     |      *
 443 |     |      * Calling conditions:
 444 |     |      *
 445 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
 446 |     |      * - When `from` is zero, the tokens were minted for `to`.
 447 |     |      * - When `to` is zero, ``from``'s tokens were burned.
 448 |     |      * - `from` and `to` are never both zero.
 449 |     |      * - `batchSize` is non-zero.
 450 |     |      *
 451 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 452 |     |      */
 453 |     |     function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
 454 |     | 
 455 |     |     /**
 456 |     |      * @dev Unsafe write access to the balances, used by extensions that "mint" tokens using an {ownerOf} override.
 457 |     |      *
 458 |     |      * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant
 459 |     |      * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such
 460 |     |      * that `ownerOf(tokenId)` is `a`.
 461 |     |      */
 462 |     |     // solhint-disable-next-line func-name-mixedcase
 463 |     |     function __unsafe_increaseBalance(address account, uint256 amount) internal {
 464 |     |         _balances[account] += amount;
 465 |     |     }
 466 |     | }
 467 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC721 compliant contract.
  10 |     |  */
  11 |     | interface IERC721 is IERC165 {
  12 |     |     /**
  13 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
  14 |     |      */
  15 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
  19 |     |      */
  20 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
  24 |     |      */
  25 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Returns the number of tokens in ``owner``'s account.
  29 |     |      */
  30 |     |     function balanceOf(address owner) external view returns (uint256 balance);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Returns the owner of the `tokenId` token.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - `tokenId` must exist.
  38 |     |      */
  39 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      *
  46 |     |      * - `from` cannot be the zero address.
  47 |     |      * - `to` cannot be the zero address.
  48 |     |      * - `tokenId` token must exist and be owned by `from`.
  49 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  50 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  51 |     |      *
  52 |     |      * Emits a {Transfer} event.
  53 |     |      */
  54 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
  58 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
  59 |     |      *
  60 |     |      * Requirements:
  61 |     |      *
  62 |     |      * - `from` cannot be the zero address.
  63 |     |      * - `to` cannot be the zero address.
  64 |     |      * - `tokenId` token must exist and be owned by `from`.
  65 |     |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
  66 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  67 |     |      *
  68 |     |      * Emits a {Transfer} event.
  69 |     |      */
  70 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Transfers `tokenId` token from `from` to `to`.
  74 |     |      *
  75 |     |      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
  76 |     |      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
  77 |     |      * understand this adds an external call which potentially creates a reentrancy vulnerability.
  78 |     |      *
  79 |     |      * Requirements:
  80 |     |      *
  81 |     |      * - `from` cannot be the zero address.
  82 |     |      * - `to` cannot be the zero address.
  83 |     |      * - `tokenId` token must be owned by `from`.
  84 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  85 |     |      *
  86 |     |      * Emits a {Transfer} event.
  87 |     |      */
  88 |     |     function transferFrom(address from, address to, uint256 tokenId) external;
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
  92 |     |      * The approval is cleared when the token is transferred.
  93 |     |      *
  94 |     |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
  95 |     |      *
  96 |     |      * Requirements:
  97 |     |      *
  98 |     |      * - The caller must own the token or be an approved operator.
  99 |     |      * - `tokenId` must exist.
 100 |     |      *
 101 |     |      * Emits an {Approval} event.
 102 |     |      */
 103 |     |     function approve(address to, uint256 tokenId) external;
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 107 |     |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
 108 |     |      *
 109 |     |      * Requirements:
 110 |     |      *
 111 |     |      * - The `operator` cannot be the caller.
 112 |     |      *
 113 |     |      * Emits an {ApprovalForAll} event.
 114 |     |      */
 115 |     |     function setApprovalForAll(address operator, bool approved) external;
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns the account approved for `tokenId` token.
 119 |     |      *
 120 |     |      * Requirements:
 121 |     |      *
 122 |     |      * - `tokenId` must exist.
 123 |     |      */
 124 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 128 |     |      *
 129 |     |      * See {setApprovalForAll}
 130 |     |      */
 131 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 132 |     | }
 133 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ERC721 token receiver interface
  8 |     |  * @dev Interface for any contract that wants to support safeTransfers
  9 |     |  * from ERC721 asset contracts.
 10 |     |  */
 11 |     | interface IERC721Receiver {
 12 |     |     /**
 13 |     |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
 14 |     |      * by `operator` from `from`, this function is called.
 15 |     |      *
 16 |     |      * It must return its Solidity selector to confirm the token transfer.
 17 |     |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
 18 |     |      *
 19 |     |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
 20 |     |      */
 21 |     |     function onERC721Received(
 22 |     |         address operator,
 23 |     |         address from,
 24 |     |         uint256 tokenId,
 25 |     |         bytes calldata data
 26 |     |     ) external returns (bytes4);
 27 |     | }
 28 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721URIStorage.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/extensions/ERC721URIStorage.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC721.sol";
  7 |     | import "../../../interfaces/IERC4906.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev ERC721 token with storage based token URI management.
 11 |     |  */
 12 |     | abstract contract ERC721URIStorage is IERC4906, ERC721 {
 13 |     |     using Strings for uint256;
 14 |     | 
 15 |     |     // Optional mapping for token URIs
 16 |     |     mapping(uint256 => string) private _tokenURIs;
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev See {IERC165-supportsInterface}
 20 |     |      */
 21 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {
 22 |     |         return interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);
 23 |     |     }
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev See {IERC721Metadata-tokenURI}.
 27 |     |      */
 28 |     |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
 29 |     |         _requireMinted(tokenId);
 30 |     | 
 31 |     |         string memory _tokenURI = _tokenURIs[tokenId];
 32 |     |         string memory base = _baseURI();
 33 |     | 
 34 |     |         // If there is no base URI, return the token URI.
 35 |     |         if (bytes(base).length == 0) {
 36 |     |             return _tokenURI;
 37 |     |         }
 38 |     |         // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
 39 |     |         if (bytes(_tokenURI).length > 0) {
 40 |     |             return string(abi.encodePacked(base, _tokenURI));
 41 |     |         }
 42 |     | 
 43 |     |         return super.tokenURI(tokenId);
 44 |     |     }
 45 |     | 
 46 |     |     /**
 47 |     |      * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
 48 |     |      *
 49 |     |      * Emits {MetadataUpdate}.
 50 |     |      *
 51 |     |      * Requirements:
 52 |     |      *
 53 |     |      * - `tokenId` must exist.
 54 |     |      */
 55 |     |     function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
 56 |     |         require(_exists(tokenId), "ERC721URIStorage: URI set of nonexistent token");
 57 |     |         _tokenURIs[tokenId] = _tokenURI;
 58 |     | 
 59 |     |         emit MetadataUpdate(tokenId);
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev See {ERC721-_burn}. This override additionally checks to see if a
 64 |     |      * token-specific URI was set for the token, and if so, it deletes the token URI from
 65 |     |      * the storage mapping.
 66 |     |      */
 67 |     |     function _burn(uint256 tokenId) internal virtual override {
 68 |     |         super._burn(tokenId);
 69 |     | 
 70 |     |         if (bytes(_tokenURIs[tokenId]).length != 0) {
 71 |     |             delete _tokenURIs[tokenId];
 72 |     |         }
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 10 |     |  * @dev See https://eips.ethereum.org/EIPS/eip-721
 11 |     |  */
 12 |     | interface IERC721Metadata is IERC721 {
 13 |     |     /**
 14 |     |      * @dev Returns the token collection name.
 15 |     |      */
 16 |     |     function name() external view returns (string memory);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Returns the token collection symbol.
 20 |     |      */
 21 |     |     function symbol() external view returns (string memory);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
 25 |     |      */
 26 |     |     function tokenURI(uint256 tokenId) external view returns (string memory);
 27 |     | }
 28 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/Counters.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title Counters
  8 |     |  * @author Matt Condon (@shrugs)
  9 |     |  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
 10 |     |  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 11 |     |  *
 12 |     |  * Include with `using Counters for Counters.Counter;`
 13 |     |  */
 14 |     | library Counters {
 15 |     |     struct Counter {
 16 |     |         // This variable should never be directly accessed by users of the library: interactions must be restricted to
 17 |     |         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
 18 |     |         // this feature: see https://github.com/ethereum/solidity/issues/4637
 19 |     |         uint256 _value; // default: 0
 20 |     |     }
 21 |     | 
 22 |     |     function current(Counter storage counter) internal view returns (uint256) {
 23 |     |         return counter._value;
 24 |     |     }
 25 |     | 
 26 |     |     function increment(Counter storage counter) internal {
 27 |     |         unchecked {
 28 |     |             counter._value += 1;
 29 |     |         }
 30 |     |     }
 31 |     | 
 32 |     |     function decrement(Counter storage counter) internal {
 33 |     |         uint256 value = counter._value;
 34 |     |         require(value > 0, "Counter: decrement overflow");
 35 |     |         unchecked {
 36 |     |             counter._value = value - 1;
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     function reset(Counter storage counter) internal {
 41 |     |         counter._value = 0;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/ShortStrings.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.8;
   5 |     | 
   6 |     | import "./StorageSlot.sol";
   7 |     | 
   8 |     | // | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |
   9 |     | // | length  | 0x                                                              BB |
  10 |     | type ShortString is bytes32;
  11 |     | 
  12 |     | /**
  13 |     |  * @dev This library provides functions to convert short memory strings
  14 |     |  * into a `ShortString` type that can be used as an immutable variable.
  15 |     |  *
  16 |     |  * Strings of arbitrary length can be optimized using this library if
  17 |     |  * they are short enough (up to 31 bytes) by packing them with their
  18 |     |  * length (1 byte) in a single EVM word (32 bytes). Additionally, a
  19 |     |  * fallback mechanism can be used for every other case.
  20 |     |  *
  21 |     |  * Usage example:
  22 |     |  *
  23 |     |  * ```solidity
  24 |     |  * contract Named {
  25 |     |  *     using ShortStrings for *;
  26 |     |  *
  27 |     |  *     ShortString private immutable _name;
  28 |     |  *     string private _nameFallback;
  29 |     |  *
  30 |     |  *     constructor(string memory contractName) {
  31 |     |  *         _name = contractName.toShortStringWithFallback(_nameFallback);
  32 |     |  *     }
  33 |     |  *
  34 |     |  *     function name() external view returns (string memory) {
  35 |     |  *         return _name.toStringWithFallback(_nameFallback);
  36 |     |  *     }
  37 |     |  * }
  38 |     |  * ```
  39 |     |  */
  40 |     | library ShortStrings {
  41 |     |     // Used as an identifier for strings longer than 31 bytes.
  42 |     |     bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;
  43 |     | 
  44 |     |     error StringTooLong(string str);
  45 |     |     error InvalidShortString();
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Encode a string of at most 31 chars into a `ShortString`.
  49 |     |      *
  50 |     |      * This will trigger a `StringTooLong` error is the input string is too long.
  51 |     |      */
  52 |     |     function toShortString(string memory str) internal pure returns (ShortString) {
  53 |     |         bytes memory bstr = bytes(str);
  54 |     |         if (bstr.length > 31) {
  55 |     |             revert StringTooLong(str);
  56 |     |         }
  57 |     |         return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Decode a `ShortString` back to a "normal" string.
  62 |     |      */
  63 |     |     function toString(ShortString sstr) internal pure returns (string memory) {
  64 |     |         uint256 len = byteLength(sstr);
  65 |     |         // using `new string(len)` would work locally but is not memory safe.
  66 |     |         string memory str = new string(32);
  67 |     |         /// @solidity memory-safe-assembly
  68 |     |         assembly {
  69 |     |             mstore(str, len)
  70 |     |             mstore(add(str, 0x20), sstr)
  71 |     |         }
  72 |     |         return str;
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Return the length of a `ShortString`.
  77 |     |      */
  78 |     |     function byteLength(ShortString sstr) internal pure returns (uint256) {
  79 |     |         uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;
  80 |     |         if (result > 31) {
  81 |     |             revert InvalidShortString();
  82 |     |         }
  83 |     |         return result;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.
  88 |     |      */
  89 |     |     function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {
  90 |     |         if (bytes(value).length < 32) {
  91 |     |             return toShortString(value);
  92 |     |         } else {
  93 |     |             StorageSlot.getStringSlot(store).value = value;
  94 |     |             return ShortString.wrap(_FALLBACK_SENTINEL);
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.
 100 |     |      */
 101 |     |     function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {
 102 |     |         if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {
 103 |     |             return toString(value);
 104 |     |         } else {
 105 |     |             return store;
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.
 111 |     |      *
 112 |     |      * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of
 113 |     |      * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.
 114 |     |      */
 115 |     |     function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {
 116 |     |         if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {
 117 |     |             return byteLength(value);
 118 |     |         } else {
 119 |     |             return bytes(store).length;
 120 |     |         }
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.0;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  19 |     |  *
  20 |     |  *     function _getImplementation() internal view returns (address) {
  21 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  22 |     |  *     }
  23 |     |  *
  24 |     |  *     function _setImplementation(address newImplementation) internal {
  25 |     |  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
  26 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  27 |     |  *     }
  28 |     |  * }
  29 |     |  * ```
  30 |     |  *
  31 |     |  * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._
  32 |     |  * _Available since v4.9 for `string`, `bytes`._
  33 |     |  */
  34 |     | library StorageSlot {
  35 |     |     struct AddressSlot {
  36 |     |         address value;
  37 |     |     }
  38 |     | 
  39 |     |     struct BooleanSlot {
  40 |     |         bool value;
  41 |     |     }
  42 |     | 
  43 |     |     struct Bytes32Slot {
  44 |     |         bytes32 value;
  45 |     |     }
  46 |     | 
  47 |     |     struct Uint256Slot {
  48 |     |         uint256 value;
  49 |     |     }
  50 |     | 
  51 |     |     struct StringSlot {
  52 |     |         string value;
  53 |     |     }
  54 |     | 
  55 |     |     struct BytesSlot {
  56 |     |         bytes value;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  61 |     |      */
  62 |     |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  63 |     |         /// @solidity memory-safe-assembly
  64 |     |         assembly {
  65 |     |             r.slot := slot
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
  71 |     |      */
  72 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  73 |     |         /// @solidity memory-safe-assembly
  74 |     |         assembly {
  75 |     |             r.slot := slot
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
  81 |     |      */
  82 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  83 |     |         /// @solidity memory-safe-assembly
  84 |     |         assembly {
  85 |     |             r.slot := slot
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
  91 |     |      */
  92 |     |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  93 |     |         /// @solidity memory-safe-assembly
  94 |     |         assembly {
  95 |     |             r.slot := slot
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns an `StringSlot` with member `value` located at `slot`.
 101 |     |      */
 102 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 103 |     |         /// @solidity memory-safe-assembly
 104 |     |         assembly {
 105 |     |             r.slot := slot
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 111 |     |      */
 112 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 113 |     |         /// @solidity memory-safe-assembly
 114 |     |         assembly {
 115 |     |             r.slot := store.slot
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev Returns an `BytesSlot` with member `value` located at `slot`.
 121 |     |      */
 122 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 123 |     |         /// @solidity memory-safe-assembly
 124 |     |         assembly {
 125 |     |             r.slot := slot
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 131 |     |      */
 132 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 133 |     |         /// @solidity memory-safe-assembly
 134 |     |         assembly {
 135 |     |             r.slot := store.slot
 136 |     |         }
 137 |     |     }
 138 |     | }
 139 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | import "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 |     |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 |     |             uint256 length = Math.log10(value) + 1;
 22 |     |             string memory buffer = new string(length);
 23 |     |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 |     |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 |     |             while (true) {
 29 |     |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 |     |                 value /= 10;
 35 |     |                 if (value == 0) break;
 36 |     |             }
 37 |     |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, Math.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 |     |         require(value == 0, "Strings: hex length insufficient");
 69 |     |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../Strings.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
  10 |     |  *
  11 |     |  * These functions can be used to verify that a message was signed by the holder
  12 |     |  * of the private keys of a given address.
  13 |     |  */
  14 |     | library ECDSA {
  15 |     |     enum RecoverError {
  16 |     |         NoError,
  17 |     |         InvalidSignature,
  18 |     |         InvalidSignatureLength,
  19 |     |         InvalidSignatureS,
  20 |     |         InvalidSignatureV // Deprecated in v4.8
  21 |     |     }
  22 |     | 
  23 |     |     function _throwError(RecoverError error) private pure {
  24 |     |         if (error == RecoverError.NoError) {
  25 |     |             return; // no error: do nothing
  26 |     |         } else if (error == RecoverError.InvalidSignature) {
  27 |     |             revert("ECDSA: invalid signature");
  28 |     |         } else if (error == RecoverError.InvalidSignatureLength) {
  29 |     |             revert("ECDSA: invalid signature length");
  30 |     |         } else if (error == RecoverError.InvalidSignatureS) {
  31 |     |             revert("ECDSA: invalid signature 's' value");
  32 |     |         }
  33 |     |     }
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  37 |     |      * `signature` or error string. This address can then be used for verification purposes.
  38 |     |      *
  39 |     |      * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
  40 |     |      * this function rejects them by requiring the `s` value to be in the lower
  41 |     |      * half order, and the `v` value to be either 27 or 28.
  42 |     |      *
  43 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  44 |     |      * verification to be secure: it is possible to craft signatures that
  45 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  46 |     |      * this is by receiving a hash of the original message (which may otherwise
  47 |     |      * be too long), and then calling {toEthSignedMessageHash} on it.
  48 |     |      *
  49 |     |      * Documentation for signature generation:
  50 |     |      * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
  51 |     |      * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
  52 |     |      *
  53 |     |      * _Available since v4.3._
  54 |     |      */
  55 |     |     function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
  56 |     |         if (signature.length == 65) {
  57 |     |             bytes32 r;
  58 |     |             bytes32 s;
  59 |     |             uint8 v;
  60 |     |             // ecrecover takes the signature parameters, and the only way to get them
  61 |     |             // currently is to use assembly.
  62 |     |             /// @solidity memory-safe-assembly
  63 |     |             assembly {
  64 |     |                 r := mload(add(signature, 0x20))
  65 |     |                 s := mload(add(signature, 0x40))
  66 |     |                 v := byte(0, mload(add(signature, 0x60)))
  67 |     |             }
  68 |     |             return tryRecover(hash, v, r, s);
  69 |     |         } else {
  70 |     |             return (address(0), RecoverError.InvalidSignatureLength);
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  76 |     |      * `signature`. This address can then be used for verification purposes.
  77 |     |      *
  78 |     |      * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
  79 |     |      * this function rejects them by requiring the `s` value to be in the lower
  80 |     |      * half order, and the `v` value to be either 27 or 28.
  81 |     |      *
  82 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  83 |     |      * verification to be secure: it is possible to craft signatures that
  84 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  85 |     |      * this is by receiving a hash of the original message (which may otherwise
  86 |     |      * be too long), and then calling {toEthSignedMessageHash} on it.
  87 |     |      */
  88 |     |     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
  89 |     |         (address recovered, RecoverError error) = tryRecover(hash, signature);
  90 |     |         _throwError(error);
  91 |     |         return recovered;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
  96 |     |      *
  97 |     |      * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
  98 |     |      *
  99 |     |      * _Available since v4.3._
 100 |     |      */
 101 |     |     function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {
 102 |     |         bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 103 |     |         uint8 v = uint8((uint256(vs) >> 255) + 27);
 104 |     |         return tryRecover(hash, v, r, s);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
 109 |     |      *
 110 |     |      * _Available since v4.2._
 111 |     |      */
 112 |     |     function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
 113 |     |         (address recovered, RecoverError error) = tryRecover(hash, r, vs);
 114 |     |         _throwError(error);
 115 |     |         return recovered;
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
 120 |     |      * `r` and `s` signature fields separately.
 121 |     |      *
 122 |     |      * _Available since v4.3._
 123 |     |      */
 124 |     |     function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {
 125 |     |         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
 126 |     |         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
 127 |     |         // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most
 128 |     |         // signatures from current libraries generate a unique signature with an s-value in the lower half order.
 129 |     |         //
 130 |     |         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
 131 |     |         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
 132 |     |         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
 133 |     |         // these malleable signatures as well.
 134 |     |         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
 135 |     |             return (address(0), RecoverError.InvalidSignatureS);
 136 |     |         }
 137 |     | 
 138 |     |         // If the signature is valid (and not malleable), return the signer address
 139 |     |         address signer = ecrecover(hash, v, r, s);
 140 |     |         if (signer == address(0)) {
 141 |     |             return (address(0), RecoverError.InvalidSignature);
 142 |     |         }
 143 |     | 
 144 |     |         return (signer, RecoverError.NoError);
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Overload of {ECDSA-recover} that receives the `v`,
 149 |     |      * `r` and `s` signature fields separately.
 150 |     |      */
 151 |     |     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
 152 |     |         (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
 153 |     |         _throwError(error);
 154 |     |         return recovered;
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev Returns an Ethereum Signed Message, created from a `hash`. This
 159 |     |      * produces hash corresponding to the one signed with the
 160 |     |      * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
 161 |     |      * JSON-RPC method as part of EIP-191.
 162 |     |      *
 163 |     |      * See {recover}.
 164 |     |      */
 165 |     |     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {
 166 |     |         // 32 is the length in bytes of hash,
 167 |     |         // enforced by the type signature above
 168 |     |         /// @solidity memory-safe-assembly
 169 |     |         assembly {
 170 |     |             mstore(0x00, "\x19Ethereum Signed Message:\n32")
 171 |     |             mstore(0x1c, hash)
 172 |     |             message := keccak256(0x00, 0x3c)
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Returns an Ethereum Signed Message, created from `s`. This
 178 |     |      * produces hash corresponding to the one signed with the
 179 |     |      * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
 180 |     |      * JSON-RPC method as part of EIP-191.
 181 |     |      *
 182 |     |      * See {recover}.
 183 |     |      */
 184 |     |     function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
 185 |     |         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @dev Returns an Ethereum Signed Typed Data, created from a
 190 |     |      * `domainSeparator` and a `structHash`. This produces hash corresponding
 191 |     |      * to the one signed with the
 192 |     |      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
 193 |     |      * JSON-RPC method as part of EIP-712.
 194 |     |      *
 195 |     |      * See {recover}.
 196 |     |      */
 197 |     |     function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {
 198 |     |         /// @solidity memory-safe-assembly
 199 |     |         assembly {
 200 |     |             let ptr := mload(0x40)
 201 |     |             mstore(ptr, "\x19\x01")
 202 |     |             mstore(add(ptr, 0x02), domainSeparator)
 203 |     |             mstore(add(ptr, 0x22), structHash)
 204 |     |             data := keccak256(ptr, 0x42)
 205 |     |         }
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Returns an Ethereum Signed Data with intended validator, created from a
 210 |     |      * `validator` and `data` according to the version 0 of EIP-191.
 211 |     |      *
 212 |     |      * See {recover}.
 213 |     |      */
 214 |     |     function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {
 215 |     |         return keccak256(abi.encodePacked("\x19\x00", validator, data));
 216 |     |     }
 217 |     | }
 218 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.8;
   5 |     | 
   6 |     | import "./ECDSA.sol";
   7 |     | import "../ShortStrings.sol";
   8 |     | import "../../interfaces/IERC5267.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.
  12 |     |  *
  13 |     |  * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,
  14 |     |  * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding
  15 |     |  * they need in their contracts using a combination of `abi.encode` and `keccak256`.
  16 |     |  *
  17 |     |  * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
  18 |     |  * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
  19 |     |  * ({_hashTypedDataV4}).
  20 |     |  *
  21 |     |  * The implementation of the domain separator was designed to be as efficient as possible while still properly updating
  22 |     |  * the chain id to protect against replay attacks on an eventual fork of the chain.
  23 |     |  *
  24 |     |  * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
  25 |     |  * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].
  26 |     |  *
  27 |     |  * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain
  28 |     |  * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the
  29 |     |  * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.
  30 |     |  *
  31 |     |  * _Available since v3.4._
  32 |     |  *
  33 |     |  * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment
  34 |     |  */
  35 |     | abstract contract EIP712 is IERC5267 {
  36 |     |     using ShortStrings for *;
  37 |     | 
  38 |     |     bytes32 private constant _TYPE_HASH =
  39 |     |         keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
  40 |     | 
  41 |     |     // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
  42 |     |     // invalidate the cached domain separator if the chain id changes.
  43 |     |     bytes32 private immutable _cachedDomainSeparator;
  44 |     |     uint256 private immutable _cachedChainId;
  45 |     |     address private immutable _cachedThis;
  46 |     | 
  47 |     |     bytes32 private immutable _hashedName;
  48 |     |     bytes32 private immutable _hashedVersion;
  49 |     | 
  50 |     |     ShortString private immutable _name;
  51 |     |     ShortString private immutable _version;
  52 |     |     string private _nameFallback;
  53 |     |     string private _versionFallback;
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Initializes the domain separator and parameter caches.
  57 |     |      *
  58 |     |      * The meaning of `name` and `version` is specified in
  59 |     |      * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:
  60 |     |      *
  61 |     |      * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
  62 |     |      * - `version`: the current major version of the signing domain.
  63 |     |      *
  64 |     |      * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
  65 |     |      * contract upgrade].
  66 |     |      */
  67 |     |     constructor(string memory name, string memory version) {
  68 |     |         _name = name.toShortStringWithFallback(_nameFallback);
  69 |     |         _version = version.toShortStringWithFallback(_versionFallback);
  70 |     |         _hashedName = keccak256(bytes(name));
  71 |     |         _hashedVersion = keccak256(bytes(version));
  72 |     | 
  73 |     |         _cachedChainId = block.chainid;
  74 |     |         _cachedDomainSeparator = _buildDomainSeparator();
  75 |     |         _cachedThis = address(this);
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Returns the domain separator for the current chain.
  80 |     |      */
  81 |     |     function _domainSeparatorV4() internal view returns (bytes32) {
  82 |     |         if (address(this) == _cachedThis && block.chainid == _cachedChainId) {
  83 |     |             return _cachedDomainSeparator;
  84 |     |         } else {
  85 |     |             return _buildDomainSeparator();
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     function _buildDomainSeparator() private view returns (bytes32) {
  90 |     |         return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
  95 |     |      * function returns the hash of the fully encoded EIP712 message for this domain.
  96 |     |      *
  97 |     |      * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
  98 |     |      *
  99 |     |      * ```solidity
 100 |     |      * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
 101 |     |      *     keccak256("Mail(address to,string contents)"),
 102 |     |      *     mailTo,
 103 |     |      *     keccak256(bytes(mailContents))
 104 |     |      * )));
 105 |     |      * address signer = ECDSA.recover(digest, signature);
 106 |     |      * ```
 107 |     |      */
 108 |     |     function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
 109 |     |         return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev See {EIP-5267}.
 114 |     |      *
 115 |     |      * _Available since v4.9._
 116 |     |      */
 117 |     |     function eip712Domain()
 118 |     |         public
 119 |     |         view
 120 |     |         virtual
 121 |     |         override
 122 |     |         returns (
 123 |     |             bytes1 fields,
 124 |     |             string memory name,
 125 |     |             string memory version,
 126 |     |             uint256 chainId,
 127 |     |             address verifyingContract,
 128 |     |             bytes32 salt,
 129 |     |             uint256[] memory extensions
 130 |     |         )
 131 |     |     {
 132 |     |         return (
 133 |     |             hex"0f", // 01111
 134 |     |             _name.toStringWithFallback(_nameFallback),
 135 |     |             _version.toStringWithFallback(_versionFallback),
 136 |     |             block.chainid,
 137 |     |             address(this),
 138 |     |             bytes32(0),
 139 |     |             new uint256[](0)
 140 |     |         );
 141 |     |     }
 142 |     | }
 143 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
  71 |     |                 // The surrounding unchecked block does not change this fact.
  72 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
  73 |     |                 return prod0 / denominator;
  74 |     |             }
  75 |     | 
  76 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  77 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  78 |     | 
  79 |     |             ///////////////////////////////////////////////
  80 |     |             // 512 by 256 division.
  81 |     |             ///////////////////////////////////////////////
  82 |     | 
  83 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  84 |     |             uint256 remainder;
  85 |     |             assembly {
  86 |     |                 // Compute remainder using mulmod.
  87 |     |                 remainder := mulmod(x, y, denominator)
  88 |     | 
  89 |     |                 // Subtract 256 bit number from 512 bit number.
  90 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  91 |     |                 prod0 := sub(prod0, remainder)
  92 |     |             }
  93 |     | 
  94 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  95 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  96 |     | 
  97 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  98 |     |             uint256 twos = denominator & (~denominator + 1);
  99 |     |             assembly {
 100 |     |                 // Divide denominator by twos.
 101 |     |                 denominator := div(denominator, twos)
 102 |     | 
 103 |     |                 // Divide [prod1 prod0] by twos.
 104 |     |                 prod0 := div(prod0, twos)
 105 |     | 
 106 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 107 |     |                 twos := add(div(sub(0, twos), twos), 1)
 108 |     |             }
 109 |     | 
 110 |     |             // Shift in bits from prod1 into prod0.
 111 |     |             prod0 |= prod1 * twos;
 112 |     | 
 113 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 114 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 115 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 116 |     |             uint256 inverse = (3 * denominator) ^ 2;
 117 |     | 
 118 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 119 |     |             // in modular arithmetic, doubling the correct bits in each step.
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 126 |     | 
 127 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 128 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 129 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 130 |     |             // is no longer required.
 131 |     |             result = prod0 * inverse;
 132 |     |             return result;
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 138 |     |      */
 139 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 140 |     |         uint256 result = mulDiv(x, y, denominator);
 141 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 142 |     |             result += 1;
 143 |     |         }
 144 |     |         return result;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 149 |     |      *
 150 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 151 |     |      */
 152 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 153 |     |         if (a == 0) {
 154 |     |             return 0;
 155 |     |         }
 156 |     | 
 157 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 158 |     |         //
 159 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 160 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 161 |     |         //
 162 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 163 |     |         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 164 |     |         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 165 |     |         //
 166 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 167 |     |         uint256 result = 1 << (log2(a) >> 1);
 168 |     | 
 169 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 170 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 171 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 172 |     |         // into the expected uint128 result.
 173 |     |         unchecked {
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             result = (result + a / result) >> 1;
 179 |     |             result = (result + a / result) >> 1;
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             return min(result, a / result);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 187 |     |      */
 188 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 189 |     |         unchecked {
 190 |     |             uint256 result = sqrt(a);
 191 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 197 |     |      * Returns 0 if given 0.
 198 |     |      */
 199 |     |     function log2(uint256 value) internal pure returns (uint256) {
 200 |     |         uint256 result = 0;
 201 |     |         unchecked {
 202 |     |             if (value >> 128 > 0) {
 203 |     |                 value >>= 128;
 204 |     |                 result += 128;
 205 |     |             }
 206 |     |             if (value >> 64 > 0) {
 207 |     |                 value >>= 64;
 208 |     |                 result += 64;
 209 |     |             }
 210 |     |             if (value >> 32 > 0) {
 211 |     |                 value >>= 32;
 212 |     |                 result += 32;
 213 |     |             }
 214 |     |             if (value >> 16 > 0) {
 215 |     |                 value >>= 16;
 216 |     |                 result += 16;
 217 |     |             }
 218 |     |             if (value >> 8 > 0) {
 219 |     |                 value >>= 8;
 220 |     |                 result += 8;
 221 |     |             }
 222 |     |             if (value >> 4 > 0) {
 223 |     |                 value >>= 4;
 224 |     |                 result += 4;
 225 |     |             }
 226 |     |             if (value >> 2 > 0) {
 227 |     |                 value >>= 2;
 228 |     |                 result += 2;
 229 |     |             }
 230 |     |             if (value >> 1 > 0) {
 231 |     |                 result += 1;
 232 |     |             }
 233 |     |         }
 234 |     |         return result;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 239 |     |      * Returns 0 if given 0.
 240 |     |      */
 241 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 242 |     |         unchecked {
 243 |     |             uint256 result = log2(value);
 244 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 250 |     |      * Returns 0 if given 0.
 251 |     |      */
 252 |     |     function log10(uint256 value) internal pure returns (uint256) {
 253 |     |         uint256 result = 0;
 254 |     |         unchecked {
 255 |     |             if (value >= 10 ** 64) {
 256 |     |                 value /= 10 ** 64;
 257 |     |                 result += 64;
 258 |     |             }
 259 |     |             if (value >= 10 ** 32) {
 260 |     |                 value /= 10 ** 32;
 261 |     |                 result += 32;
 262 |     |             }
 263 |     |             if (value >= 10 ** 16) {
 264 |     |                 value /= 10 ** 16;
 265 |     |                 result += 16;
 266 |     |             }
 267 |     |             if (value >= 10 ** 8) {
 268 |     |                 value /= 10 ** 8;
 269 |     |                 result += 8;
 270 |     |             }
 271 |     |             if (value >= 10 ** 4) {
 272 |     |                 value /= 10 ** 4;
 273 |     |                 result += 4;
 274 |     |             }
 275 |     |             if (value >= 10 ** 2) {
 276 |     |                 value /= 10 ** 2;
 277 |     |                 result += 2;
 278 |     |             }
 279 |     |             if (value >= 10 ** 1) {
 280 |     |                 result += 1;
 281 |     |             }
 282 |     |         }
 283 |     |         return result;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 288 |     |      * Returns 0 if given 0.
 289 |     |      */
 290 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 291 |     |         unchecked {
 292 |     |             uint256 result = log10(value);
 293 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 299 |     |      * Returns 0 if given 0.
 300 |     |      *
 301 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 302 |     |      */
 303 |     |     function log256(uint256 value) internal pure returns (uint256) {
 304 |     |         uint256 result = 0;
 305 |     |         unchecked {
 306 |     |             if (value >> 128 > 0) {
 307 |     |                 value >>= 128;
 308 |     |                 result += 16;
 309 |     |             }
 310 |     |             if (value >> 64 > 0) {
 311 |     |                 value >>= 64;
 312 |     |                 result += 8;
 313 |     |             }
 314 |     |             if (value >> 32 > 0) {
 315 |     |                 value >>= 32;
 316 |     |                 result += 4;
 317 |     |             }
 318 |     |             if (value >> 16 > 0) {
 319 |     |                 value >>= 16;
 320 |     |                 result += 2;
 321 |     |             }
 322 |     |             if (value >> 8 > 0) {
 323 |     |                 result += 1;
 324 |     |             }
 325 |     |         }
 326 |     |         return result;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 331 |     |      * Returns 0 if given 0.
 332 |     |      */
 333 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 334 |     |         unchecked {
 335 |     |             uint256 result = log256(value);
 336 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 337 |     |         }
 338 |     |     }
 339 |     | }
 340 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/Echidna/Account.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | contract Account {}
 5 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/Echidna/Debugger.sol
  1 |     | /*
  2 |     | Original from https://github.com/perimetersec/drips-fuzzing/blob/main/src/echidna/tools/Debugger.sol
  3 |     | */
  4 |     | 
  5 |     | // SPDX-License-Identifier: MIT
  6 |     | pragma solidity ^0.8.0;
  7 |     | 
  8 |     | library Debugger {
  9 |     |     event Debug(string debugString);
 10 |     |     event Debug(string description, string data);
 11 |     |     event Debug(string prefix, string description, string data);
 12 |     |     event Debug(string description, bytes32 data);
 13 |     |     event Debug(string prefix, string description, bytes32 data);
 14 |     |     event Debug(string description, uint256 data);
 15 |     |     event Debug(string prefix, string description, uint256 data);
 16 |     |     event Debug(string description, int256 data);
 17 |     |     event Debug(string prefix, string description, int256 data);
 18 |     |     event Debug(string description, address data);
 19 |     |     event Debug(string prefix, string description, address data);
 20 |     |     event Debug(string description, bool data);
 21 |     |     event Debug(string prefix, string description, bool data);
 22 |     | 
 23 |     |     function log(string memory debugString) internal {
 24 |     |         emit Debug(debugString);
 25 |     |     }
 26 |     | 
 27 |     |     function log(string memory description, string memory data) internal {
 28 |     |         emit Debug(description, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(
 32 |     |         string memory prefix,
 33 |     |         string memory description,
 34 |     |         string memory data
 35 |     |     ) internal {
 36 |     |         emit Debug(prefix, description, data);
 37 |     |     }
 38 |     | 
 39 |     |     function log(string memory description, bytes32 data) internal {
 40 |     |         emit Debug(description, data);
 41 |     |     }
 42 |     | 
 43 |     |     function log(
 44 |     |         string memory prefix,
 45 |     |         string memory description,
 46 |     |         bytes32 data
 47 |     |     ) internal {
 48 |     |         emit Debug(prefix, description, data);
 49 |     |     }
 50 |     | 
 51 |     |     function log(string memory description, uint256 data) internal {
 52 |     |         emit Debug(description, data);
 53 |     |     }
 54 |     | 
 55 |     |     function log(
 56 |     |         string memory prefix,
 57 |     |         string memory description,
 58 |     |         uint256 data
 59 |     |     ) internal {
 60 |     |         emit Debug(prefix, description, data);
 61 |     |     }
 62 |     | 
 63 |     |     function log(string memory description, int256 data) internal {
 64 |     |         emit Debug(description, data);
 65 |     |     }
 66 |     | 
 67 |     |     function log(
 68 |     |         string memory prefix,
 69 |     |         string memory description,
 70 |     |         int256 data
 71 |     |     ) internal {
 72 |     |         emit Debug(prefix, description, data);
 73 |     |     }
 74 |     | 
 75 |     |     function log(string memory description, address data) internal {
 76 |     |         emit Debug(description, data);
 77 |     |     }
 78 |     | 
 79 |     |     function log(
 80 |     |         string memory prefix,
 81 |     |         string memory description,
 82 |     |         address data
 83 |     |     ) internal {
 84 |     |         emit Debug(prefix, description, data);
 85 |     |     }
 86 |     | 
 87 |     |     function log(string memory description, bool data) internal {
 88 |     |         emit Debug(description, data);
 89 |     |     }
 90 |     | 
 91 |     |     function log(
 92 |     |         string memory prefix,
 93 |     |         string memory description,
 94 |     |         bool data
 95 |     |     ) internal {
 96 |     |         emit Debug(prefix, description, data);
 97 |     |     }
 98 |     | }

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/Echidna/Echidna2PortalV2.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import "../PortalV2MultiAsset.sol";
   5 |     | import "../MintBurnToken.sol";
   6 |     | import {VirtualLP} from "src/V2MultiAsset/VirtualLP.sol";
   7 |     | import "./EchidnaConfig.sol";
   8 |     | 
   9 | *r  | contract Echidna2PortalV2 is EchidnaConfig {
  10 |     |     MintBurnToken internal psmToken;
  11 |     |     VirtualLP internal virtualLP;
  12 |     | 
  13 |     |     // External token addresses
  14 |     |     address constant WETH_ADDRESS = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
  15 |     |     address internal constant PSM_ADDRESS =
  16 |     |         0x17A8541B82BF67e10B0874284b4Ae66858cb1fd5;
  17 |     |     address constant esVKA = 0x95b3F9797077DDCa971aB8524b439553a220EB2A;
  18 |     | 
  19 |     |     address private constant _PRINCIPAL_TOKEN_ADDRESS_USDC =
  20 |     |         0xaf88d065e77c8cC2239327C5EDb3A432268e5831;
  21 |     |     address private constant _PRINCIPAL_TOKEN_ADDRESS_ETH = address(0);
  22 |     | 
  23 |     |     // General constants
  24 |     |     uint256 constant _TERMINAL_MAX_LOCK_DURATION = 157680000;
  25 |     |     uint256 private constant SECONDS_PER_YEAR = 31536000; // seconds in a 365 day year
  26 |     |     uint256 internal maxLockDuration = 7776000; // 7776000 starting value for maximum allowed lock duration of users balance in seconds (90 days)
  27 |     |     uint256 private constant OWNER_DURATION = 31536000; // 1 Year
  28 |     | 
  29 |     |     // Portal Constructor values
  30 |     |     uint256 constant _TARGET_CONSTANT_USDC = 440528634361 * 1e36;
  31 |     |     uint256 constant _TARGET_CONSTANT_WETH = 125714213 * 1e36;
  32 |     | 
  33 |     |     uint256 constant _FUNDING_PHASE_DURATION = 604800; // 7 days
  34 |     |     uint256 constant _FUNDING_MIN_AMOUNT = 1e25; // 10M PSM
  35 |     | 
  36 |     |     uint256 constant _DECIMALS = 18;
  37 |     |     uint256 constant _DECIMALS_USDC = 6;
  38 |     | 
  39 |     |     uint256 constant _AMOUNT_TO_CONVERT = 100000 * 1e18;
  40 |     | 
  41 |     |     string _META_DATA_URI = "abcd";
  42 |     | 
  43 |     |     // time
  44 |     |     uint256 timestamp;
  45 |     |     uint256 fundingPhase;
  46 |     |     uint256 ownerExpiry;
  47 |     |     uint256 hundredYearsLater;
  48 |     | 
  49 |     |     // Token Instances
  50 |     |     IERC20 psm = IERC20(PSM_ADDRESS);
  51 |     |     IERC20 usdc = IERC20(_PRINCIPAL_TOKEN_ADDRESS_USDC);
  52 |     |     IERC20 weth = IERC20(WETH_ADDRESS);
  53 |     | 
  54 |     |     // Portals & LP
  55 |     |     PortalV2MultiAsset internal portal_USDC;
  56 |     |     PortalV2MultiAsset internal portal_ETH;
  57 |     | 
  58 |     |     // Simulated USDC distributor
  59 |     |     address usdcSender = 0xF977814e90dA44bFA03b6295A0616a897441aceC;
  60 |     | 
  61 |     |     // PSM Treasury
  62 |     |     address psmSender = 0xAb845D09933f52af5642FC87Dd8FBbf553fd7B33;
  63 |     | 
  64 |     |     // starting token amounts
  65 |     |     uint256 usdcAmount = 1e12; // 1M USDC
  66 |     |     uint256 psmAmount = 1e25; // 10M PSM
  67 |     |     uint256 usdcSendAmount = 1e9; // 1k USDC
  68 |     | 
  69 |     |     constructor() payable {
  70 |     |         // hevm.roll(195078119); // sets the correct block number
  71 |     |         // hevm.warp(1711625676); // sets the expected timestamp for the block number
  72 |     | 
  73 |     |         // Create Virtual LP instance
  74 |     |         virtualLP = new VirtualLP(
  75 |     |             psmSender,
  76 |     |             _AMOUNT_TO_CONVERT,
  77 |     |             _FUNDING_PHASE_DURATION,
  78 |     |             _FUNDING_MIN_AMOUNT
  79 |     |         );
  80 |     |         address _VIRTUAL_LP = address(virtualLP);
  81 |     | 
  82 |     |         // Create Portal instances
  83 |     |         portal_USDC = new PortalV2MultiAsset(
  84 |     |             _VIRTUAL_LP,
  85 |     |             _TARGET_CONSTANT_USDC,
  86 |     |             _PRINCIPAL_TOKEN_ADDRESS_USDC,
  87 |     |             _DECIMALS_USDC,
  88 |     |             "USD Coin",
  89 |     |             "USDC",
  90 |     |             _META_DATA_URI
  91 |     |         );
  92 |     |         portal_ETH = new PortalV2MultiAsset(
  93 |     |             _VIRTUAL_LP,
  94 |     |             _TARGET_CONSTANT_WETH,
  95 |     |             _PRINCIPAL_TOKEN_ADDRESS_ETH,
  96 |     |             _DECIMALS,
  97 |     |             "ETHER",
  98 |     |             "ETH",
  99 |     |             _META_DATA_URI
 100 |     |         );
 101 |     | 
 102 |     |          // creation time
 103 |     |         timestamp = block.timestamp;
 104 |     |         fundingPhase = timestamp + _FUNDING_PHASE_DURATION;
 105 |     |         ownerExpiry = timestamp + OWNER_DURATION;
 106 |     |         hundredYearsLater = timestamp + 100 * SECONDS_PER_YEAR;
 107 |     | 
 108 |     |         // Deal tokens to addresses
 109 |     |         // hevm.deal(USER1, 1 ether);
 110 |     |         hevm.prank(psmSender);
 111 |     |         psm.transfer(USER1, psmAmount);
 112 |     |         hevm.prank(usdcSender);
 113 |     |         usdc.transfer(USER1, usdcAmount);
 114 |     | 
 115 |     |         // hevm.deal(USER2, 1 ether);
 116 |     |         hevm.prank(psmSender);
 117 |     |         psm.transfer(USER2, psmAmount);
 118 |     |         hevm.prank(usdcSender);
 119 |     |         usdc.transfer(USER2, usdcAmount);
 120 |     | 
 121 |     |         // hevm.deal(USER3, 1 ether);
 122 |     |         hevm.prank(psmSender);
 123 |     |         psm.transfer(USER3, psmAmount);
 124 |     |         hevm.prank(usdcSender);
 125 |     |         usdc.transfer(USER3, usdcAmount);
 126 |     |     }
 127 |     | 
 128 |     |     // Echidna test for staking and unstaking invariant
 129 | *   |     function test_stake_unstake_invariant() public {
 130 | *   |         uint256 stakeAmount = 1000e18; // Simplified stake amount
 131 | *   |         hevm.prank(USER1);
 132 | *r  |         portal_ETH.stake(stakeAmount);
 133 |     |         hevm.prank(USER1);
 134 |     |         portal_ETH.unstake(stakeAmount);
 135 |     | 
 136 |     |         // Assertion to ensure total staked balance is correct
 137 |     |         assert(portal_ETH.totalPrincipalStaked() == 0);
 138 |     |     }
 139 |     | 
 140 |     |     // Echidna test for portal energy token minting and burning consistency
 141 | *   |     function test_portal_energy_token_mint_burn() public {
 142 | *   |         uint256 mintAmount = 500e18; // Simplified mint amount
 143 | *   |         hevm.prank(USER2);
 144 | *r  |         portal_ETH.mintPortalEnergyToken(USER2, mintAmount); // Assuming this function exists and works directly for simplicity
 145 |     |         hevm.prank(USER2);
 146 |     |         portal_ETH.burnPortalEnergyToken(USER2, mintAmount); // Assuming direct burn for simplicity
 147 |     | 
 148 |     |         // Assertion to check portal energy balance consistency
 149 |     |         // This is a placeholder for the actual logic you might want to assert
 150 |     |         // E.g., asserting that the user's portal energy is back to the initial state
 151 |     |         // This might require adjustments based on the actual implementation details
 152 |     |         assert(true); // Placeholder assertion
 153 |     |     }
 154 |     | }
 155 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/Echidna/EchidnaConfig.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./IHevm.sol";
  5 |     | import "./Debugger.sol";
  6 |     | 
  7 |     | contract EchidnaConfig {
  8 |     |     IHevm hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
  9 |     | 
 10 |     |     // Constant echidna addresses
 11 | *   |     address internal constant USER1 = address(0x10000);
 12 | *   |     address internal constant USER2 = address(0x20000);
 13 |     |     address internal constant USER3 = address(0x30000);
 14 |     | 
 15 |     |     address payable internal ADDRESS_ACCOUNT0;
 16 |     |     address payable internal ADDRESS_ACCOUNT1;
 17 |     |     address payable internal ADDRESS_ACCOUNT2;
 18 |     |         
 19 |     |     uint256 internal constant STARTING_TOKEN_BALANCE = 1_000_000_000e6;
 20 |     |     uint256 internal constant STARTING_ETH_BALANCE = 1000 ether;
 21 |     | }

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/Echidna/EchidnaPortalV2MultiAsset.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import "../PortalV2MultiAsset.sol";
   5 |     | import "../MintBurnToken.sol";
   6 |     | import {VirtualLP} from "src/V2MultiAsset/VirtualLP.sol";
   7 |     | import "./EchidnaConfig.sol";
   8 |     | 
   9 |     | contract EchidnaPortalV2MultiAsset is EchidnaConfig {
  10 |     |     MintBurnToken public psmToken;
  11 |     |     VirtualLP public virtualLP;
  12 |     | 
  13 |     |     // External token addresses
  14 |     |     address constant WETH_ADDRESS = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
  15 |     |     address public constant PSM_ADDRESS =
  16 |     |         0x17A8541B82BF67e10B0874284b4Ae66858cb1fd5;
  17 |     |     address constant esVKA = 0x95b3F9797077DDCa971aB8524b439553a220EB2A;
  18 |     | 
  19 |     |     // Vaultka staking contracts
  20 |     |     address constant SINGLE_STAKING =
  21 |     |         0x314223E2fA375F972E159002Eb72A96301E99e22;
  22 |     |     address constant DUAL_STAKING = 0x31Fa38A6381e9d1f4770C73AB14a0ced1528A65E;
  23 |     | 
  24 |     |     uint256 constant _POOL_ID_USDC = 5;
  25 |     |     uint256 constant _POOL_ID_WETH = 10;
  26 |     | 
  27 |     |     address private constant USDC_WATER =
  28 |     |         0x9045ae36f963b7184861BDce205ea8B08913B48c;
  29 |     |     address private constant WETH_WATER =
  30 |     |         0x8A98929750e6709Af765F976c6bddb5BfFE6C06c;
  31 |     | 
  32 |     |     address private constant _PRINCIPAL_TOKEN_ADDRESS_USDC =
  33 |     |         0xaf88d065e77c8cC2239327C5EDb3A432268e5831;
  34 |     |     address private constant _PRINCIPAL_TOKEN_ADDRESS_ETH = address(0);
  35 |     | 
  36 |     |     // General constants
  37 |     |     uint256 constant _TERMINAL_MAX_LOCK_DURATION = 157680000;
  38 |     |     uint256 private constant SECONDS_PER_YEAR = 31536000; // seconds in a 365 day year
  39 |     |     uint256 public maxLockDuration = 7776000; // 7776000 starting value for maximum allowed lock duration of users balance in seconds (90 days)
  40 |     |     uint256 private constant OWNER_DURATION = 31536000; // 1 Year
  41 |     | 
  42 |     |     // Portal Constructor values
  43 |     |     uint256 constant _TARGET_CONSTANT_USDC = 440528634361 * 1e36;
  44 |     |     uint256 constant _TARGET_CONSTANT_WETH = 125714213 * 1e36;
  45 |     | 
  46 |     |     uint256 constant _FUNDING_PHASE_DURATION = 604800; // 7 days
  47 |     |     uint256 constant _FUNDING_MIN_AMOUNT = 1e25; // 10M PSM
  48 |     | 
  49 |     |     uint256 constant _DECIMALS = 18;
  50 |     |     uint256 constant _DECIMALS_USDC = 6;
  51 |     | 
  52 |     |     uint256 constant _AMOUNT_TO_CONVERT = 100000 * 1e18;
  53 |     | 
  54 |     |     string _META_DATA_URI = "abcd";
  55 |     | 
  56 |     |     // time
  57 |     |     uint256 timestamp;
  58 |     |     uint256 fundingPhase;
  59 |     |     uint256 ownerExpiry;
  60 |     |     uint256 hundredYearsLater;
  61 |     | 
  62 |     |     // Token Instances
  63 |     |     IERC20 psm = IERC20(PSM_ADDRESS);
  64 |     |     IERC20 usdc = IERC20(_PRINCIPAL_TOKEN_ADDRESS_USDC);
  65 |     |     IERC20 weth = IERC20(WETH_ADDRESS);
  66 |     | 
  67 |     |     // Portals & LP
  68 |     |     PortalV2MultiAsset public portal_USDC;
  69 |     |     PortalV2MultiAsset public portal_ETH;
  70 |     | 
  71 |     |     // Simulated USDC distributor
  72 |     |     address usdcSender = 0xF977814e90dA44bFA03b6295A0616a897441aceC;
  73 |     | 
  74 |     |     // PSM Treasury
  75 |     |     address psmSender = 0xAb845D09933f52af5642FC87Dd8FBbf553fd7B33;
  76 |     | 
  77 |     |     // starting token amounts
  78 |     |     uint256 usdcAmount = 1e12; // 1M USDC
  79 |     |     uint256 psmAmount = 1e25; // 10M PSM
  80 |     |     uint256 usdcSendAmount = 1e9; // 1k USDC
  81 |     | 
  82 |     |     constructor() {
  83 |     |         hevm.roll(195078119); // sets the correct block number
  84 |     |         // hevm.warp(); // sets the expected timestamp for the block number
  85 |     | 
  86 |     |         // Create Virtual LP instance
  87 |     |         virtualLP = new VirtualLP(
  88 |     |             psmSender,
  89 |     |             _AMOUNT_TO_CONVERT,
  90 |     |             _FUNDING_PHASE_DURATION,
  91 |     |             _FUNDING_MIN_AMOUNT
  92 |     |         );
  93 |     |         address _VIRTUAL_LP = address(virtualLP);
  94 |     | 
  95 |     |         // Create Portal instances
  96 |     |         portal_USDC = new PortalV2MultiAsset(
  97 |     |             _VIRTUAL_LP,
  98 |     |             _TARGET_CONSTANT_USDC,
  99 |     |             _PRINCIPAL_TOKEN_ADDRESS_USDC,
 100 |     |             _DECIMALS_USDC,
 101 |     |             "USD Coin",
 102 |     |             "USDC",
 103 |     |             _META_DATA_URI
 104 |     |         );
 105 |     |         portal_ETH = new PortalV2MultiAsset(
 106 |     |             _VIRTUAL_LP,
 107 |     |             _TARGET_CONSTANT_WETH,
 108 |     |             _PRINCIPAL_TOKEN_ADDRESS_ETH,
 109 |     |             _DECIMALS,
 110 |     |             "ETHER",
 111 |     |             "ETH",
 112 |     |             _META_DATA_URI
 113 |     |         );
 114 |     | 
 115 |     |          // creation time
 116 |     |         timestamp = block.timestamp;
 117 |     |         fundingPhase = timestamp + _FUNDING_PHASE_DURATION;
 118 |     |         ownerExpiry = timestamp + OWNER_DURATION;
 119 |     |         hundredYearsLater = timestamp + 100 * SECONDS_PER_YEAR;
 120 |     | 
 121 |     |         // Deal tokens to addresses
 122 |     |         hevm.deal(USER1, 1 ether);
 123 |     |         hevm.prank(psmSender);
 124 |     |         psm.transfer(USER1, psmAmount);
 125 |     |         hevm.prank(usdcSender);
 126 |     |         usdc.transfer(USER1, usdcAmount);
 127 |     | 
 128 |     |         // hevm.deal(USER2, 1 ether);
 129 |     |         hevm.prank(psmSender);
 130 |     |         psm.transfer(USER2, psmAmount);
 131 |     |         hevm.prank(usdcSender);
 132 |     |         usdc.transfer(USER2, usdcAmount);
 133 |     | 
 134 |     |         // hevm.deal(USER3, 1 ether);
 135 |     |         hevm.prank(psmSender);
 136 |     |         psm.transfer(USER3, psmAmount);
 137 |     |         hevm.prank(usdcSender);
 138 |     |         usdc.transfer(USER3, usdcAmount);
 139 |     |     }
 140 |     | 
 141 |     |     // Echidna test for staking and unstaking invariant
 142 |     |     function test_stake_unstake_invariant() public {
 143 |     |         uint256 stakeAmount = 1000e18; // Simplified stake amount
 144 |     |         hevm.prank(USER1);
 145 |     |         portal_ETH.stake(stakeAmount);
 146 |     |         hevm.prank(USER1);
 147 |     |         portal_ETH.unstake(stakeAmount);
 148 |     | 
 149 |     |         // Assertion to ensure total staked balance is correct
 150 |     |         assert(portal_ETH.totalPrincipalStaked() == 0);
 151 |     |     }
 152 |     | 
 153 |     |     // Echidna test for portal energy token minting and burning consistency
 154 |     |     function test_portal_energy_token_mint_burn() public {
 155 |     |         uint256 mintAmount = 500e18; // Simplified mint amount
 156 |     |         hevm.prank(USER2);
 157 |     |         portal_ETH.mintPortalEnergyToken(USER2, mintAmount); // Assuming this function exists and works directly for simplicity
 158 |     |         hevm.prank(USER2);
 159 |     |         portal_ETH.burnPortalEnergyToken(USER2, mintAmount); // Assuming direct burn for simplicity
 160 |     | 
 161 |     |         // Assertion to check portal energy balance consistency
 162 |     |         // This is a placeholder for the actual logic you might want to assert
 163 |     |         // E.g., asserting that the user's portal energy is back to the initial state
 164 |     |         // This might require adjustments based on the actual implementation details
 165 |     |         assert(true); // Placeholder assertion
 166 |     |     }
 167 |     | }
 168 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/Echidna/EchidnaSetup.sol
  1 |     | // // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | // import "./IHevm.sol";
  4 |     | // import "./EchidnaConfig.sol";
  5 |     | // import "./Debugger.sol";
  6 |     | // import "./Account.sol";
  7 |     | 
  8 |     | // import "../interfaces/IUSDC.sol";
  9 |     | // import "../interfaces/IcEther.sol";
 10 |     | 
 11 |     | // contract EchidnaSetup is EchidnaConfig {
 12 |     | 
 13 |     | //     Account account0 = new Account(0);
 14 |     | //     Account account1 = new Account(2);
 15 |     | //     Account account2 = new Account(128);
 16 |     | 
 17 |     | //     IUSDC usdc = IUSDC(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
 18 |     | //     IcEther fEth = IcEther(payable(0x26267e41CeCa7C8E0f143554Af707336f27Fa051));
 19 |     | 
 20 |     | //     constructor() {
 21 |     | //         // not sure if still necessary, but just in case
 22 |     | //         hevm.roll(195078119);
 23 |     | 
 24 |     | //         hevm.prank(usdc.masterMinter());
 25 |     | //         usdc.configureMinter(address(this), type(uint256).max);
 26 |     | 
 27 |     | //         ADDRESS_ACCOUNT0 = payable(address(account0));
 28 |     | //         ADDRESS_ACCOUNT0 = payable(address(account1));
 29 |     | //         ADDRESS_ACCOUNT2 = payable(address(account2));
 30 |     | 
 31 |     | //         ADDRESS_ACCOUNT0.transfer(STARTING_ETH_BALANCE);
 32 |     | //         ADDRESS_ACCOUNT1.transfer(STARTING_ETH_BALANCE);
 33 |     | //         ADDRESS_ACCOUNT2.transfer(STARTING_ETH_BALANCE);
 34 |     | 
 35 |     | //         usdc.mint(ADDRESS_ACCOUNT0, STARTING_TOKEN_BALANCE);
 36 |     | //         usdc.mint(ADDRESS_ACCOUNT1, STARTING_TOKEN_BALANCE);
 37 |     | //         usdc.mint(ADDRESS_ACCOUNT2, STARTING_TOKEN_BALANCE);
 38 |     | 
 39 |     | //         hevm.prank(ADDRESS_ACCOUNT0);
 40 |     | //         usdc.approve(address(fUsdc), type(uint256).max);
 41 |     | //         hevm.prank(ADDRESS_ACCOUNT1);
 42 |     | //         usdc.approve(address(fUsdc), type(uint256).max);
 43 |     | //         hevm.prank(ADDRESS_ACCOUNT2);
 44 |     | //         usdc.approve(address(fUsdc), type(uint256).max);
 45 |     | //     }
 46 |     | // }
 47 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/Echidna/IHevm.sol
  1 |     | /*
  2 |     | https://github.com/ethereum/hevm/blob/main/doc/src/controlling-the-unit-testing-environment.md#cheat-codes
  3 |     | */
  4 |     | 
  5 |     | // SPDX-License-Identifier: MIT
  6 |     | pragma solidity ^0.8.0;
  7 |     | 
  8 |     | interface IHevm {
  9 |     |     function warp(uint256 x) external;
 10 |     | 
 11 |     |     function roll(uint256 x) external;
 12 |     | 
 13 |     |     function store(
 14 |     |         address c,
 15 |     |         bytes32 loc,
 16 |     |         bytes32 val
 17 |     |     ) external;
 18 |     | 
 19 |     |     function load(address c, bytes32 loc) external returns (bytes32 val);
 20 |     | 
 21 |     |     function sign(uint256 sk, bytes32 digest)
 22 |     |         external
 23 |     |         returns (
 24 |     |             uint8 v,
 25 |     |             bytes32 r,
 26 |     |             bytes32 s
 27 |     |         );
 28 |     | 
 29 |     |     function addr(uint256 sk) external returns (address addr);
 30 |     | 
 31 |     |     function ffi(string[] calldata) external returns (bytes memory);
 32 |     | 
 33 |     |     function prank(address sender) external;
 34 |     | 
 35 |     |     function deal(address usr, uint256 amt) external;
 36 |     | 
 37 |     |     function assume(bool b) external;
 38 |     | }

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/MintBurnToken.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-only
  2 |     | pragma solidity =0.8.19;
  3 |     | 
  4 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
  6 |     | import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
  7 |     | 
  8 |     | error NotOwner();
  9 |     | 
 10 |     | contract MintBurnToken is ERC20, ERC20Burnable, ERC20Permit {
 11 |     |     address public immutable OWNER;
 12 |     | 
 13 |     |     constructor(
 14 |     |         string memory name,
 15 |     |         string memory symbol
 16 |     |     ) ERC20(name, symbol) ERC20Permit(name) {
 17 |     |         OWNER = msg.sender;
 18 |     |     }
 19 |     | 
 20 |     |     modifier onlyOwner() {
 21 |     |         if (msg.sender != OWNER) {
 22 |     |             revert NotOwner();
 23 |     |         }
 24 |     |         _;
 25 |     |     }
 26 |     | 
 27 |     |     function mint(address to, uint256 amount) external onlyOwner {
 28 |     |         _mint(to, amount);
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/PortalNFT.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-only
   2 |     | pragma solidity =0.8.19;
   3 |     | import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
   4 |     | import {ERC721URIStorage} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
   5 |     | import {IPortalV2MultiAsset} from "./interfaces/IPortalV2MultiAsset.sol";
   6 |     | 
   7 |     | error NotOwner();
   8 |     | error NotOwnerOfNFT();
   9 |     | 
  10 |     | /// @notice This NFT contract can mint and redeem stakes in the deploying Portal
  11 |     | /// @dev Must be deployed by the Portal which becomes the owner with mint and burn privileges
  12 |     | contract PortalNFT is ERC721URIStorage {
  13 |     |     constructor(
  14 |     |         uint256 _decimalsAdjustment,
  15 |     |         string memory _name,
  16 |     |         string memory _symbol,
  17 |     |         string memory _metadataURI
  18 |     |     ) ERC721(_name, _symbol) {
  19 |     |         OWNER = msg.sender;
  20 |     |         DECIMALS_ADJUSTMENT = _decimalsAdjustment;
  21 |     |         metadataURI = _metadataURI;
  22 |     |         portal = IPortalV2MultiAsset(msg.sender);
  23 |     |     }
  24 |     | 
  25 |     |     // ========================
  26 |     |     //    VARIABLES & MODIFIER
  27 |     |     // ========================
  28 |     |     IPortalV2MultiAsset public portal;
  29 |     | 
  30 |     |     address private immutable OWNER;
  31 |     | 
  32 |     |     struct AccountNFT {
  33 |     |         uint256 mintTime;
  34 |     |         uint256 lastMaxLockDuration;
  35 |     |         uint256 stakedBalance;
  36 |     |         uint256 portalEnergy;
  37 |     |     }
  38 |     | 
  39 |     |     mapping(uint256 tokenID => AccountNFT) public accounts;
  40 |     | 
  41 |     |     uint256 public totalSupply;
  42 |     |     uint256 private constant SECONDS_PER_YEAR = 31536000;
  43 |     |     uint256 private immutable DECIMALS_ADJUSTMENT;
  44 |     |     string private metadataURI; // Metadata URI for all NFTs of this Portal
  45 |     | 
  46 |     |     modifier onlyOwner() {
  47 |     |         if (msg.sender != OWNER) {
  48 |     |             revert NotOwner();
  49 |     |         }
  50 |     |         _;
  51 |     |     }
  52 |     | 
  53 |     |     // ========================
  54 |     |     //    FUNCTIONS
  55 |     |     // ========================
  56 |     |     /// @dev Get the current values for stakedBalance and portalEnergy of a particular NFT
  57 |     |     function getAccount(
  58 |     |         uint256 _tokenId
  59 |     |     ) public view returns (uint256 stakedBalance, uint256 portalEnergy) {
  60 |     |         _requireMinted(_tokenId);
  61 |     | 
  62 |     |         AccountNFT memory account = accounts[_tokenId];
  63 |     |         /// @dev Calculate the Portal Energy earned since minting
  64 |     |         uint256 portalEnergyEarned = (account.stakedBalance *
  65 |     |             (block.timestamp - account.mintTime) *
  66 |     |             1e18);
  67 |     | 
  68 |     |         /// @dev Calculate the gain of Portal Energy from maxLockDuration increase
  69 |     |         uint256 portalEnergyIncrease = (account.stakedBalance *
  70 |     |             (portal.maxLockDuration() - account.lastMaxLockDuration) *
  71 |     |             1e18);
  72 |     | 
  73 |     |         /// @dev Summarize changes in Portal Energy and divide by common denominator
  74 |     |         account.portalEnergy +=
  75 |     |             (portalEnergyEarned + portalEnergyIncrease) /
  76 |     |             (SECONDS_PER_YEAR * DECIMALS_ADJUSTMENT);
  77 |     | 
  78 |     |         /// @dev Return the values
  79 |     |         stakedBalance = account.stakedBalance;
  80 |     |         portalEnergy = account.portalEnergy;
  81 |     |     }
  82 |     | 
  83 |     |     /// @dev Mint new NFT, can only be called by owner (Portal)
  84 |     |     function mint(
  85 |     |         address _recipient,
  86 |     |         uint256 _lastMaxLockDuration,
  87 |     |         uint256 _stakedBalance,
  88 |     |         uint256 _portalEnergy
  89 |     |     ) external onlyOwner returns (uint256 nftID) {
  90 |     |         totalSupply++;
  91 |     |         _safeMint(_recipient, totalSupply);
  92 |     |         _setTokenURI(totalSupply, metadataURI);
  93 |     | 
  94 |     |         AccountNFT memory account;
  95 |     |         account.mintTime = block.timestamp;
  96 |     |         account.lastMaxLockDuration = _lastMaxLockDuration;
  97 |     |         account.stakedBalance = _stakedBalance;
  98 |     |         account.portalEnergy = _portalEnergy;
  99 |     | 
 100 |     |         accounts[totalSupply] = account;
 101 |     | 
 102 |     |         nftID = totalSupply;
 103 |     |     }
 104 |     | 
 105 |     |     /// @dev Redeem Position NFT to receive internal Account in Portal
 106 |     |     /// @dev Can only be called by the owner (Portal)
 107 |     |     function redeem(
 108 |     |         address ownerOfNFT,
 109 |     |         uint256 _tokenId
 110 |     |     ) external onlyOwner returns (uint256 stakedBalance, uint256 portalEnergy) {
 111 |     |         if (ownerOfNFT != _ownerOf(_tokenId)) {
 112 |     |             revert NotOwnerOfNFT();
 113 |     |         }
 114 |     | 
 115 |     |         /// @dev return the relevant values
 116 |     |         (stakedBalance, portalEnergy) = getAccount(_tokenId);
 117 |     | 
 118 |     |         /// @dev Burn the NFT and delete the associated account in the NFT contract
 119 |     |         _burn(_tokenId);
 120 |     |         delete accounts[_tokenId];
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/PortalV2MultiAsset.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-only
   2 |     | pragma solidity =0.8.19;
   3 |     | 
   4 |     | import {MintBurnToken} from "./MintBurnToken.sol";
   5 |     | import {PortalNFT} from "./PortalNFT.sol";
   6 |     | import {IVirtualLP} from "./interfaces/IVirtualLP.sol";
   7 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   8 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
   9 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  10 |     | import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
  11 |     | 
  12 |     | interface IWETH {
  13 |     |     function deposit() external payable;
  14 |     | }
  15 |     | 
  16 |     | // ============================================
  17 |     | // ==              CUSTOM ERRORS             ==
  18 |     | // ============================================
  19 |     | error DeadlineExpired();
  20 |     | error DurationLocked();
  21 |     | error DurationTooLow();
  22 |     | error EmptyAccount();
  23 |     | error InactiveLP();
  24 |     | error InsufficientBalance();
  25 |     | error InsufficientReceived();
  26 |     | error InsufficientStakeBalance();
  27 |     | error InvalidAddress();
  28 |     | error InvalidAmount();
  29 |     | error InvalidConstructor();
  30 |     | error NativeTokenNotAllowed();
  31 |     | error TokenExists();
  32 |     | 
  33 |     | /// @title Portal Contract V2 with shared Virtual LP
  34 |     | /// @author Possum Labs
  35 |     | /** @notice This contract accepts user deposits and withdrawals of a specific token
  36 |     |  * The deposits are redirected to an external protocol to generate yield
  37 |     |  * Yield is claimed and collected with this contract
  38 |     |  * Users accrue portalEnergy points over time while staking their tokens
  39 |     |  * portalEnergy can be exchanged against the PSM token using the internal Liquidity Pool or minted as ERC20
  40 |     |  * PortalEnergy Tokens can be burned to increase a recipient internal portalEnergy balance
  41 |     |  * Users can buy more portalEnergy via the internal LP by spending PSM
  42 |     |  * The contract can receive PSM tokens during the funding phase and issues bTokens as receipt
  43 |     |  * bTokens received during the funding phase are used to initialize the internal LP
  44 |     |  * bTokens can be redeemed against the fundingRewardPool which consists of PSM tokens
  45 |     |  * The fundingRewardPool is filled over time by taking a 10% cut from the Converter
  46 |     |  * The Converter is an arbitrage mechanism that allows anyone to sweep the contract balance of a token
  47 |     |  * When triggering the Converter, the caller (arbitrager) must send a fixed amount of PSM tokens to the contract
  48 |     |  */
  49 | *   | contract PortalV2MultiAsset is ReentrancyGuard {
  50 |     |     constructor(
  51 |     |         address _VIRTUAL_LP,
  52 |     |         uint256 _CONSTANT_PRODUCT,
  53 |     |         address _PRINCIPAL_TOKEN_ADDRESS,
  54 |     |         uint256 _DECIMALS,
  55 |     |         string memory _PRINCIPAL_NAME,
  56 |     |         string memory _PRINCIPAL_SYMBOL,
  57 |     |         string memory _META_DATA_URI
  58 |     |     ) {
  59 |     |         if (_VIRTUAL_LP == address(0)) {
  60 |     |             revert InvalidConstructor();
  61 |     |         }
  62 |     |         if (_CONSTANT_PRODUCT < 1e25) {
  63 |     |             revert InvalidConstructor();
  64 |     |         }
  65 |     |         if (_DECIMALS == 0) {
  66 |     |             revert InvalidConstructor();
  67 |     |         }
  68 |     |         if (keccak256(bytes(_PRINCIPAL_NAME)) == keccak256(bytes(""))) {
  69 |     |             revert InvalidConstructor();
  70 |     |         }
  71 |     |         if (keccak256(bytes(_PRINCIPAL_SYMBOL)) == keccak256(bytes(""))) {
  72 |     |             revert InvalidConstructor();
  73 |     |         }
  74 |     |         if (keccak256(bytes(_META_DATA_URI)) == keccak256(bytes(""))) {
  75 |     |             revert InvalidConstructor();
  76 |     |         }
  77 |     | 
  78 |     |         VIRTUAL_LP = _VIRTUAL_LP;
  79 |     |         CONSTANT_PRODUCT = _CONSTANT_PRODUCT;
  80 |     |         PRINCIPAL_TOKEN_ADDRESS = _PRINCIPAL_TOKEN_ADDRESS;
  81 |     |         DECIMALS_ADJUSTMENT = 10 ** _DECIMALS;
  82 |     |         NFT_META_DATA = _META_DATA_URI;
  83 |     |         PRINCIPAL_NAME = _PRINCIPAL_NAME;
  84 |     |         PRINCIPAL_SYMBOL = _PRINCIPAL_SYMBOL;
  85 |     |         CREATION_TIME = block.timestamp;
  86 |     |         virtualLP = IVirtualLP(VIRTUAL_LP);
  87 |     |         DENOMINATOR = SECONDS_PER_YEAR * DECIMALS_ADJUSTMENT;
  88 |     |     }
  89 |     | 
  90 |     |     // ============================================
  91 |     |     // ==            GLOBAL VARIABLES            ==
  92 |     |     // ============================================
  93 |     |     using SafeERC20 for IERC20;
  94 |     | 
  95 |     |     // general
  96 |     |     address constant WETH_ADDRESS = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
  97 |     |     address constant PSM_ADDRESS = 0x17A8541B82BF67e10B0874284b4Ae66858cb1fd5; // address of PSM token
  98 |     |     uint256 constant TERMINAL_MAX_LOCK_DURATION = 157680000; // terminal maximum lock duration of a user stake in seconds (5y)
  99 |     |     uint256 constant SECONDS_PER_YEAR = 31536000; // seconds in a 365 day year
 100 |     |     string PRINCIPAL_NAME; // Name of the staking token
 101 |     |     string PRINCIPAL_SYMBOL; // Symbol of the staking token
 102 |     | 
 103 |     |     uint256 public immutable CREATION_TIME; // time stamp of deployment
 104 |     |     uint256 public immutable DECIMALS_ADJUSTMENT; // scaling factor to account for the decimals of the principal token
 105 |     |     uint256 private immutable DENOMINATOR;
 106 |     | 
 107 |     |     MintBurnToken public portalEnergyToken; // the ERC20 representation of portalEnergy
 108 |     |     PortalNFT public portalNFT; // The NFT contract deployed by the Portal that can store accounts
 109 |     |     bool public portalEnergyTokenCreated; // flag for PE token deployment
 110 |     |     bool public portalNFTcreated; // flag for Portal NFT contract deployment
 111 |     | 
 112 |     |     address public immutable PRINCIPAL_TOKEN_ADDRESS; // address of the token accepted by the strategy as deposit
 113 |     |     string public NFT_META_DATA; // IPFS uri for Portal Position NFTs metadata
 114 |     |     uint256 public maxLockDuration = 7776000; // starting value for maximum allowed lock duration of user balance in seconds (90 days)
 115 |     |     uint256 public totalPrincipalStaked; // returns how much principal is staked by all users combined
 116 |     |     bool public lockDurationUpdateable = true; // flag to signal if the lock duration can still be updated
 117 |     | 
 118 |     |     // exchange related
 119 |     |     IVirtualLP private virtualLP;
 120 |     |     uint256 public immutable CONSTANT_PRODUCT; // The constantProduct with which the Portal will be activated
 121 |     |     address public immutable VIRTUAL_LP; // Address of the collective, virtual LP
 122 |     |     uint256 public constant LP_PROTECTION_HURDLE = 1; // percent reduction of output amount when minting or buying PE
 123 |     | 
 124 |     |     // staking related
 125 |     |     struct Account {
 126 |     |         uint256 lastUpdateTime;
 127 |     |         uint256 lastMaxLockDuration;
 128 |     |         uint256 stakedBalance;
 129 |     |         uint256 maxStakeDebt;
 130 |     |         uint256 portalEnergy;
 131 |     |     }
 132 |     |     mapping(address => Account) public accounts; // Associate users with their stake position
 133 |     | 
 134 |     |     // ============================================
 135 |     |     // ==                EVENTS                  ==
 136 |     |     // ============================================
 137 |     |     // --- Events related to internal exchange PSM vs. portalEnergy ---
 138 |     |     event PortalEnergyBuyExecuted(
 139 |     |         address indexed caller,
 140 |     |         address indexed recipient,
 141 |     |         uint256 amount
 142 |     |     );
 143 |     |     event PortalEnergySellExecuted(
 144 |     |         address indexed caller,
 145 |     |         address indexed recipient,
 146 |     |         uint256 amount
 147 |     |     );
 148 |     | 
 149 |     |     // --- Events related to minting and burning portalEnergyToken & NFTs ---
 150 |     |     event PortalEnergyMinted(
 151 |     |         address indexed caller,
 152 |     |         address indexed recipient,
 153 |     |         uint256 amount
 154 |     |     );
 155 |     |     event PortalEnergyBurned(
 156 |     |         address indexed caller,
 157 |     |         address indexed recipient,
 158 |     |         uint256 amount
 159 |     |     );
 160 |     | 
 161 |     |     event PortalNFTminted(
 162 |     |         address indexed caller,
 163 |     |         address indexed recipient,
 164 |     |         uint256 nftID
 165 |     |     );
 166 |     | 
 167 |     |     event PortalNFTredeemed(
 168 |     |         address indexed caller,
 169 |     |         address indexed recipient,
 170 |     |         uint256 nftID
 171 |     |     );
 172 |     | 
 173 |     |     // --- Events related to staking & unstaking ---
 174 |     |     event PrincipalStaked(address indexed user, uint256 amountStaked);
 175 |     |     event PrincipalUnstaked(address indexed user, uint256 amountUnstaked);
 176 |     | 
 177 |     |     event StakePositionUpdated(
 178 |     |         address indexed user,
 179 |     |         uint256 lastUpdateTime,
 180 |     |         uint256 lastMaxLockDuration,
 181 |     |         uint256 stakedBalance,
 182 |     |         uint256 maxStakeDebt,
 183 |     |         uint256 portalEnergy
 184 |     |     );
 185 |     | 
 186 |     |     // ============================================
 187 |     |     // ==               MODIFIERS                ==
 188 |     |     // ============================================
 189 |     |     modifier activeLP() {
 190 | *   |         if (!virtualLP.isActiveLP()) {
 191 | *   |             revert InactiveLP();
 192 |     |         }
 193 |     |         _;
 194 |     |     }
 195 |     | 
 196 |     |     // ============================================
 197 |     |     // ==           STAKING & UNSTAKING          ==
 198 |     |     // ============================================
 199 |     |     /// @notice Simulate updating a user stake position and return the values without updating the struct
 200 |     |     /// @dev Returns the simulated up-to-date user stake information
 201 |     |     /// @dev Considers changes from staking or unstaking including burning amount of PE tokens
 202 |     |     /// @param _user The user whose stake position is to be updated
 203 |     |     /// @param _amount The amount to add or subtract from the user's stake position
 204 |     |     /// @param _isPositiveAmount True for staking (add), false for unstaking (subtract)
 205 | *   |     function getUpdateAccount(
 206 |     |         address _user,
 207 |     |         uint256 _amount,
 208 |     |         bool _isPositiveAmount
 209 |     |     )
 210 |     |         public
 211 |     |         view
 212 |     |         returns (
 213 | *   |             uint256 lastUpdateTime,
 214 |     |             uint256 lastMaxLockDuration,
 215 |     |             uint256 stakedBalance,
 216 |     |             uint256 maxStakeDebt,
 217 |     |             uint256 portalEnergy,
 218 |     |             uint256 availableToWithdraw,
 219 |     |             uint256 portalEnergyTokensRequired
 220 |     |         )
 221 | *   |     {
 222 |     |         /// @dev Load user account into memory
 223 | *   |         Account memory account = accounts[_user];
 224 |     | 
 225 |     |         /// @dev initialize helper variables
 226 | *   |         uint256 amount = _amount; // to avoid stack too deep issue
 227 | *   |         bool isPositive = _isPositiveAmount; // to avoid stack too deep issue
 228 |     |         uint256 portalEnergyNetChange;
 229 | *   |         uint256 timePassed = block.timestamp - account.lastUpdateTime;
 230 | *   |         uint256 maxLockDifference = maxLockDuration -
 231 | *   |             account.lastMaxLockDuration;
 232 | *   |         uint256 adjustedPE = amount * maxLockDuration * 1e18;
 233 | *   |         stakedBalance = account.stakedBalance;
 234 |     | 
 235 |     |         /// @dev Check that the Stake Balance is sufficient for unstaking the amount
 236 | *   |         if (!isPositive && amount > stakedBalance) {
 237 |     |             revert InsufficientStakeBalance();
 238 |     |         }
 239 |     | 
 240 |     |         /// @dev Check the user account state based on lastUpdateTime
 241 |     |         /// @dev If this variable is 0, the user never staked and could not earn PE
 242 | *   |         if (account.lastUpdateTime > 0) {
 243 |     |             /// @dev Calculate the Portal Energy earned since the last update
 244 |     |             uint256 portalEnergyEarned = stakedBalance * timePassed;
 245 |     | 
 246 |     |             /// @dev Calculate the gain of Portal Energy from maxLockDuration increase
 247 |     |             uint256 portalEnergyIncrease = stakedBalance * maxLockDifference;
 248 |     | 
 249 |     |             /// @dev Summarize Portal Energy changes and divide by common denominator
 250 |     |             portalEnergyNetChange =
 251 |     |                 ((portalEnergyEarned + portalEnergyIncrease) * 1e18) /
 252 |     |                 DENOMINATOR;
 253 |     |         }
 254 |     | 
 255 |     |         /// @dev Calculate the adjustment of Portal Energy from balance change
 256 | *   |         uint256 portalEnergyAdjustment = adjustedPE / DENOMINATOR;
 257 |     | 
 258 |     |         /// @dev Calculate the amount of Portal Energy Tokens to be burned for unstaking the amount
 259 | *   |         portalEnergyTokensRequired = !isPositive &&
 260 |     |             portalEnergyAdjustment >
 261 |     |             (account.portalEnergy + portalEnergyNetChange)
 262 | *   |             ? portalEnergyAdjustment -
 263 |     |                 (account.portalEnergy + portalEnergyNetChange)
 264 | *   |             : 0;
 265 |     | 
 266 |     |         /// @dev Set the last update time to the current timestamp
 267 | *   |         lastUpdateTime = block.timestamp;
 268 |     | 
 269 |     |         /// @dev Update the last maxLockDuration
 270 | *   |         lastMaxLockDuration = maxLockDuration;
 271 |     | 
 272 |     |         /// @dev Update the user's staked balance and consider stake or unstake
 273 | *   |         stakedBalance = isPositive
 274 | *   |             ? stakedBalance + amount
 275 |     |             : stakedBalance - amount;
 276 |     | 
 277 |     |         /// @dev Update the user's max stake debt
 278 | *   |         maxStakeDebt = (stakedBalance * maxLockDuration * 1e18) / DENOMINATOR;
 279 |     | 
 280 |     |         /// @dev Update the user's portalEnergy and account for stake or unstake
 281 |     |         /// @dev This will be 0 if Portal Energy Tokens must be burned
 282 | *   |         portalEnergy = isPositive
 283 | *   |             ? account.portalEnergy +
 284 | *   |                 portalEnergyNetChange +
 285 | *   |                 portalEnergyAdjustment
 286 |     |             : account.portalEnergy +
 287 |     |                 portalEnergyTokensRequired +
 288 |     |                 portalEnergyNetChange -
 289 |     |                 portalEnergyAdjustment;
 290 |     | 
 291 |     |         /// @dev Update amount available to withdraw
 292 | *   |         availableToWithdraw = portalEnergy >= maxStakeDebt
 293 | *   |             ? stakedBalance
 294 |     |             : (stakedBalance * portalEnergy) / maxStakeDebt;
 295 |     |     }
 296 |     | 
 297 |     |     /// @notice Update user data to the current state
 298 |     |     /// @dev This function updates the user data to the current state
 299 |     |     /// @dev It takes memory inputs and stores them into the user account struct
 300 |     |     /// @param _user The user whose data is to be updated
 301 |     |     /// @param _stakedBalance The current Staked Balance of the user
 302 |     |     /// @param _maxStakeDebt The current maximum Stake Debt of the user
 303 |     |     /// @param _portalEnergy The current Portal Energy of the user
 304 |     |     function _updateAccount(
 305 |     |         address _user,
 306 |     |         uint256 _stakedBalance,
 307 |     |         uint256 _maxStakeDebt,
 308 |     |         uint256 _portalEnergy
 309 |     |     ) private {
 310 |     |         /// @dev Update the user account data
 311 |     |         Account storage account = accounts[_user];
 312 |     |         account.lastUpdateTime = block.timestamp;
 313 |     |         account.lastMaxLockDuration = maxLockDuration;
 314 |     |         account.stakedBalance = _stakedBalance;
 315 |     |         account.maxStakeDebt = _maxStakeDebt;
 316 |     |         account.portalEnergy = _portalEnergy;
 317 |     | 
 318 |     |         /// @dev Emit an event with the updated stake information
 319 |     |         emit StakePositionUpdated(
 320 |     |             _user,
 321 |     |             account.lastUpdateTime,
 322 |     |             account.lastMaxLockDuration,
 323 |     |             account.stakedBalance,
 324 |     |             account.maxStakeDebt,
 325 |     |             account.portalEnergy
 326 |     |         );
 327 |     |     }
 328 |     | 
 329 |     |     /// @notice Stake the principal token into the Portal & redirect principal to yield source
 330 |     |     /// @dev This function allows users to stake their principal tokens into the Portal
 331 |     |     /// @dev Can only be called if LP is active
 332 |     |     /// @dev Does not follow CEI pattern for optimisation reasons. The handled tokens are trusted.
 333 |     |     /// @dev Update the user account
 334 |     |     /// @dev Update the global tracker of staked principal
 335 |     |     /// @dev Deposit the principal into the yield source (external protocol)
 336 |     |     /// @param _amount The amount of tokens to stake
 337 | *   |     function stake(uint256 _amount) external payable activeLP nonReentrant {
 338 |     |         /// @dev Convert native ETH to WETH for contract, then send to LP
 339 |     |         /// @dev This section must sit before using _amount elsewhere to guarantee consistency
 340 |     |         /// @dev This knowingly deviates from the CEI pattern
 341 |     |         if (PRINCIPAL_TOKEN_ADDRESS == address(0)) {
 342 |     |             /// @dev Wrap ETH into WETH received by the contract
 343 |     |             _amount = msg.value;
 344 |     |             IWETH(WETH_ADDRESS).deposit{value: _amount}();
 345 |     | 
 346 |     |             /// @dev Send WETH to virtual LP
 347 |     |             IERC20(WETH_ADDRESS).transfer(VIRTUAL_LP, _amount);
 348 |     |         } else {
 349 |     |             /// @dev If not native ETH, transfer principal token to contract
 350 |     |             /// @dev Prevent contract from receiving ETH when principal is ERC20
 351 |     |             if (msg.value > 0) {
 352 |     |                 revert NativeTokenNotAllowed();
 353 |     |             }
 354 |     | 
 355 |     |             /// @dev Transfer token from user to virtual LP
 356 |     |             IERC20(PRINCIPAL_TOKEN_ADDRESS).safeTransferFrom(
 357 |     |                 msg.sender,
 358 |     |                 VIRTUAL_LP,
 359 |     |                 _amount
 360 |     |             );
 361 |     |         }
 362 |     | 
 363 |     |         /// @dev Revert if the staked amount is zero
 364 |     |         if (_amount == 0) {
 365 |     |             revert InvalidAmount();
 366 |     |         }
 367 |     | 
 368 |     |         /// @dev Get the current state of the user stake
 369 |     |         (
 370 |     |             ,
 371 |     |             ,
 372 |     |             uint256 stakedBalance,
 373 |     |             uint256 maxStakeDebt,
 374 |     |             uint256 portalEnergy,
 375 |     |             ,
 376 |     | 
 377 |     |         ) = getUpdateAccount(msg.sender, _amount, true);
 378 |     | 
 379 |     |         /// @dev Update the user stake struct
 380 |     |         _updateAccount(msg.sender, stakedBalance, maxStakeDebt, portalEnergy);
 381 |     | 
 382 |     |         /// @dev Update the total stake balance
 383 |     |         totalPrincipalStaked += _amount;
 384 |     | 
 385 |     |         /// @dev Deposit the principal into the yield source (external protocol)
 386 |     |         virtualLP.depositToYieldSource(PRINCIPAL_TOKEN_ADDRESS, _amount);
 387 |     | 
 388 |     |         /// @dev Emit event that the stake was successful
 389 |     |         emit PrincipalStaked(msg.sender, _amount);
 390 |     |     }
 391 |     | 
 392 |     |     /// @notice Serve unstaking requests & withdraw principal from yield source
 393 |     |     /// @dev This function allows users to unstake their tokens
 394 |     |     /// @dev Update the user account
 395 |     |     /// @dev Update the global tracker of staked principal
 396 |     |     /// @dev Burn Portal Energy Tokens from caller to top up account balance if required
 397 |     |     /// @dev Withdraw the matching amount of principal from the yield source (external protocol)
 398 |     |     /// @dev Send the principal tokens to the user
 399 |     |     /// @param _amount The amount of tokens to unstake
 400 | *   |     function unstake(uint256 _amount) external nonReentrant {
 401 |     |         /// @dev Check that the unstaked amount is greater than zero
 402 |     |         if (_amount == 0) {
 403 |     |             revert InvalidAmount();
 404 |     |         }
 405 |     | 
 406 |     |         /// @dev Get the current state of the user stake
 407 |     |         /// @dev Throws if caller tries to unstake more than stake balance
 408 |     |         /// @dev Will burn Portal Energy tokens if account has insufficient Portal Energy
 409 |     |         (
 410 |     |             ,
 411 |     |             ,
 412 |     |             uint256 stakedBalance,
 413 |     |             uint256 maxStakeDebt,
 414 |     |             uint256 portalEnergy,
 415 |     |             ,
 416 |     |             uint256 portalEnergyTokensRequired
 417 |     |         ) = getUpdateAccount(msg.sender, _amount, false);
 418 |     | 
 419 |     |         /// @dev Update the user stake struct
 420 |     |         _updateAccount(msg.sender, stakedBalance, maxStakeDebt, portalEnergy);
 421 |     | 
 422 |     |         /// @dev Update the global tracker of staked principal
 423 |     |         totalPrincipalStaked -= _amount;
 424 |     | 
 425 |     |         /// @dev Burn portalEnergyToken from the caller's wallet, throws if insufficient balance
 426 |     |         if (portalEnergyTokensRequired > 0) {
 427 |     |             portalEnergyToken.burnFrom(msg.sender, portalEnergyTokensRequired);
 428 |     |         }
 429 |     | 
 430 |     |         /// @dev Withdraw the assets from external Protocol and send to user
 431 |     |         virtualLP.withdrawFromYieldSource(
 432 |     |             PRINCIPAL_TOKEN_ADDRESS,
 433 |     |             msg.sender,
 434 |     |             _amount
 435 |     |         );
 436 |     | 
 437 |     |         /// @dev Emit event that tokens have been unstaked
 438 |     |         emit PrincipalUnstaked(msg.sender, _amount);
 439 |     |     }
 440 |     | 
 441 |     |     // ============================================
 442 |     |     // ==         NFT Position Management        ==
 443 |     |     // ============================================
 444 |     |     /// @notice This function deploys the NFT contract unique to this Portal
 445 |     |     /// @dev Deploy an NFT contract with name and symbol related to the principal token
 446 |     |     /// @dev Can only be called once
 447 |     |     function create_portalNFT() external {
 448 |     |         // Check if the NFT contract is already deployed
 449 |     |         if (portalNFTcreated) {
 450 |     |             revert TokenExists();
 451 |     |         }
 452 |     | 
 453 |     |         /// @dev Update the token creation flag to prevent future calls
 454 |     |         portalNFTcreated = true;
 455 |     | 
 456 |     |         /// @dev Build the NFT contract with name and symbol based on the principal token of this Portal
 457 |     |         string memory name = concatenate("Portal-Position-", PRINCIPAL_NAME);
 458 |     | 
 459 |     |         string memory symbol = concatenate("P-", PRINCIPAL_SYMBOL);
 460 |     | 
 461 |     |         /// @dev Deploy the token and update the related storage variable so that other functions can work
 462 |     |         portalNFT = new PortalNFT(
 463 |     |             DECIMALS_ADJUSTMENT,
 464 |     |             name,
 465 |     |             symbol,
 466 |     |             NFT_META_DATA
 467 |     |         );
 468 |     |     }
 469 |     | 
 470 |     |     /// @notice This function allows users to store their Account in a transferrable NFT
 471 |     |     /// @dev Mint a Portal NFT with the vital information of caller account to a recipient
 472 |     |     /// @dev Delete the caller account
 473 |     |     function mintNFTposition(address _recipient) external {
 474 |     |         /// @dev Check that the recipient is a valid address
 475 |     |         if (_recipient == address(0)) {
 476 |     |             revert InvalidAddress();
 477 |     |         }
 478 |     | 
 479 |     |         /// @dev Get the current state of the user stake
 480 |     |         (
 481 |     |             ,
 482 |     |             uint256 lastMaxLockDuration,
 483 |     |             uint256 stakedBalance,
 484 |     |             ,
 485 |     |             uint256 portalEnergy,
 486 |     |             ,
 487 |     | 
 488 |     |         ) = getUpdateAccount(msg.sender, 0, true);
 489 |     | 
 490 |     |         // check that caller has an account with PE or staked balance > 0
 491 |     |         if (portalEnergy == 0 && stakedBalance == 0) {
 492 |     |             revert EmptyAccount();
 493 |     |         }
 494 |     |         /// @dev delete the caller account
 495 |     |         delete accounts[msg.sender];
 496 |     | 
 497 |     |         /// @dev mint NFT to recipient containing the account information, get the returned ID
 498 |     |         uint256 nftID = portalNFT.mint(
 499 |     |             _recipient,
 500 |     |             lastMaxLockDuration,
 501 |     |             stakedBalance,
 502 |     |             portalEnergy
 503 |     |         );
 504 |     | 
 505 |     |         /// @dev Emit event that the NFT was minted
 506 |     |         emit PortalNFTminted(msg.sender, _recipient, nftID);
 507 |     |     }
 508 |     | 
 509 |     |     /// @notice This function allows users to redeem (burn) their PortalNFT for its content
 510 |     |     /// @dev Update the user account to current state. Required because stake balance can change which impacts PE earning
 511 |     |     /// @dev Burn the NFT and retrieve its balances (stake balance & portalEnergy)
 512 |     |     /// @dev Add the NFT values to the account of the user
 513 |     |     function redeemNFTposition(uint256 _tokenId) external {
 514 |     |         /// @dev Get the current state of the user Account
 515 |     |         (
 516 |     |             ,
 517 |     |             ,
 518 |     |             uint256 stakedBalance,
 519 |     |             uint256 maxStakeDebt,
 520 |     |             uint256 portalEnergy,
 521 |     |             ,
 522 |     | 
 523 |     |         ) = getUpdateAccount(msg.sender, 0, true);
 524 |     | 
 525 |     |         /// @dev Redeem the NFT and get the returned paramters
 526 |     |         (uint256 stakedBalanceNFT, uint256 portalEnergyNFT) = portalNFT.redeem(
 527 |     |             msg.sender,
 528 |     |             _tokenId
 529 |     |         );
 530 |     | 
 531 |     |         /// @dev Update user Account
 532 |     |         stakedBalance += stakedBalanceNFT;
 533 |     |         portalEnergy += portalEnergyNFT;
 534 |     |         maxStakeDebt = (stakedBalance * maxLockDuration * 1e18) / DENOMINATOR;
 535 |     |         _updateAccount(msg.sender, stakedBalance, maxStakeDebt, portalEnergy);
 536 |     | 
 537 |     |         /// @dev Emit event that the Portal NFT was redeemed
 538 |     |         emit PortalNFTredeemed(msg.sender, msg.sender, _tokenId);
 539 |     |     }
 540 |     | 
 541 |     |     // ============================================
 542 |     |     // ==               VIRTUAL LP               ==
 543 |     |     // ============================================
 544 |     |     /// @notice Users sell PSM into the Portal to top up portalEnergy balance of a recipient
 545 |     |     /// @dev This function allows users to sell PSM tokens to the contract to increase a recipient portalEnergy
 546 |     |     /// @dev Get the correct price from the quote function
 547 |     |     /// @dev Increase the portalEnergy of the recipient by the amount of portalEnergy received
 548 |     |     /// @dev Transfer the PSM tokens from the caller to the contract
 549 |     |     /// @param _recipient The recipient of the Portal Energy credit
 550 |     |     /// @param _amountInputPSM The amount of PSM tokens to sell
 551 |     |     /// @param _minReceived The minimum amount of portalEnergy to receive
 552 |     |     /// @param _deadline The unix timestamp that marks the deadline for order execution
 553 |     |     function buyPortalEnergy(
 554 |     |         address _recipient,
 555 |     |         uint256 _amountInputPSM,
 556 |     |         uint256 _minReceived,
 557 |     |         uint256 _deadline
 558 |     |     ) external nonReentrant {
 559 |     |         /// @dev Check that the input amount & minimum received is greater than zero
 560 |     |         if (_amountInputPSM == 0 || _minReceived == 0) {
 561 |     |             revert InvalidAmount();
 562 |     |         }
 563 |     | 
 564 |     |         /// @dev Check that the recipient is a valid address
 565 |     |         if (_recipient == address(0)) {
 566 |     |             revert InvalidAddress();
 567 |     |         }
 568 |     | 
 569 |     |         /// @dev Check that the deadline has not expired
 570 |     |         if (_deadline < block.timestamp) {
 571 |     |             revert DeadlineExpired();
 572 |     |         }
 573 |     | 
 574 |     |         /// @dev Get the amount of portalEnergy received based on the amount of PSM tokens sold
 575 |     |         uint256 amountReceived = quoteBuyPortalEnergy(_amountInputPSM);
 576 |     | 
 577 |     |         /// @dev Check that the amount of portalEnergy received is greater than or equal to the minimum expected output
 578 |     |         if (amountReceived < _minReceived) {
 579 |     |             revert InsufficientReceived();
 580 |     |         }
 581 |     | 
 582 |     |         /// @dev Increase the portalEnergy of the recipient by the amount of portalEnergy received
 583 |     |         accounts[_recipient].portalEnergy += amountReceived;
 584 |     | 
 585 |     |         /// @dev Transfer the PSM tokens from the caller to the Virtual LP
 586 |     |         IERC20(PSM_ADDRESS).transferFrom(
 587 |     |             msg.sender,
 588 |     |             VIRTUAL_LP,
 589 |     |             _amountInputPSM
 590 |     |         );
 591 |     | 
 592 |     |         /// @dev Emit the portalEnergyBuyExecuted event
 593 |     |         emit PortalEnergyBuyExecuted(msg.sender, _recipient, amountReceived);
 594 |     |     }
 595 |     | 
 596 |     |     /// @notice Users sell portalEnergy into the Portal to receive PSM to a recipient address
 597 |     |     /// @dev This function allows users to sell portalEnergy to the contract to increase a recipient PSM
 598 |     |     /// @dev Get the output amount from the quote function
 599 |     |     /// @dev Reduce the portalEnergy balance of the caller by the amount of portalEnergy sold
 600 |     |     /// @dev Send PSM to the recipient
 601 |     |     /// @param _recipient The recipient of the PSM tokens
 602 |     |     /// @param _amountInputPE The amount of Portal Energy to sell
 603 |     |     /// @param _minReceived The minimum amount of PSM to receive
 604 |     |     /// @param _deadline The unix timestamp that marks the deadline for order execution
 605 |     |     function sellPortalEnergy(
 606 |     |         address _recipient,
 607 |     |         uint256 _amountInputPE,
 608 |     |         uint256 _minReceived,
 609 |     |         uint256 _deadline
 610 |     |     ) external nonReentrant {
 611 |     |         /// @dev Check that the input amount & minimum received is greater than zero
 612 |     |         if (_amountInputPE == 0 || _minReceived == 0) {
 613 |     |             revert InvalidAmount();
 614 |     |         }
 615 |     | 
 616 |     |         /// @dev Check that the recipient is a valid address
 617 |     |         if (_recipient == address(0)) {
 618 |     |             revert InvalidAddress();
 619 |     |         }
 620 |     | 
 621 |     |         /// @dev Check that the deadline has not expired
 622 |     |         if (_deadline < block.timestamp) {
 623 |     |             revert DeadlineExpired();
 624 |     |         }
 625 |     | 
 626 |     |         /// @dev Get the current state of user stake
 627 |     |         (
 628 |     |             ,
 629 |     |             ,
 630 |     |             uint256 stakedBalance,
 631 |     |             uint256 maxStakeDebt,
 632 |     |             uint256 portalEnergy,
 633 |     |             ,
 634 |     | 
 635 |     |         ) = getUpdateAccount(msg.sender, 0, true);
 636 |     | 
 637 |     |         /// @dev Require that the user has enough portalEnergy to sell
 638 |     |         if (portalEnergy < _amountInputPE) {
 639 |     |             revert InsufficientBalance();
 640 |     |         }
 641 |     | 
 642 |     |         /// @dev Calculate the amount of output token received based on the amount of portalEnergy sold
 643 |     |         uint256 amountReceived = quoteSellPortalEnergy(_amountInputPE);
 644 |     | 
 645 |     |         /// @dev Check that the amount of output token received is greater than or equal to the minimum expected output
 646 |     |         if (amountReceived < _minReceived) {
 647 |     |             revert InsufficientReceived();
 648 |     |         }
 649 |     | 
 650 |     |         /// @dev Calculate the user post-trade Portal Energy balance
 651 |     |         portalEnergy -= _amountInputPE;
 652 |     | 
 653 |     |         /// @dev Update the user stake struct
 654 |     |         _updateAccount(msg.sender, stakedBalance, maxStakeDebt, portalEnergy);
 655 |     | 
 656 |     |         /// @dev Instruct the Virtual LP to send PSM directly to the recipient
 657 |     |         virtualLP.PSM_sendToPortalUser(_recipient, amountReceived);
 658 |     | 
 659 |     |         /// @dev Emit the portalEnergySellExecuted event
 660 |     |         emit PortalEnergySellExecuted(msg.sender, _recipient, _amountInputPE);
 661 |     |     }
 662 |     | 
 663 |     |     /// @notice Simulate buying portalEnergy (output) with PSM tokens (input) and return amount received (output)
 664 |     |     /// @dev This function allows the caller to simulate a portalEnergy buy order of any size
 665 |     |     /// @dev Can only be called when the LP is active to avoid bad output and to prevent exchange
 666 |     |     /// @dev Update the token reserves to get the exchange price
 667 |     |     /// @param _amountInputPSM The amount of PSM tokens sold
 668 |     |     /// @return amountReceived The amount of portalEnergy received by the recipient
 669 |     |     function quoteBuyPortalEnergy(
 670 |     |         uint256 _amountInputPSM
 671 |     |     ) public view activeLP returns (uint256 amountReceived) {
 672 |     |         /// @dev Calculate the PSM token reserve (input)
 673 |     |         uint256 reserve0 = IERC20(PSM_ADDRESS).balanceOf(VIRTUAL_LP) -
 674 |     |             virtualLP.fundingRewardPool();
 675 |     | 
 676 |     |         /// @dev Calculate the reserve of portalEnergy (output)
 677 |     |         uint256 reserve1 = CONSTANT_PRODUCT / reserve0;
 678 |     | 
 679 |     |         /// @dev Reduce amount by the LP Protection Hurdle to prevent sandwich attacks
 680 |     |         _amountInputPSM =
 681 |     |             (_amountInputPSM * (100 - LP_PROTECTION_HURDLE)) /
 682 |     |             100;
 683 |     | 
 684 |     |         /// @dev Calculate the amount of portalEnergy received based on the amount of PSM tokens sold
 685 |     |         amountReceived =
 686 |     |             (_amountInputPSM * reserve1) /
 687 |     |             (_amountInputPSM + reserve0);
 688 |     |     }
 689 |     | 
 690 |     |     /// @notice Simulate selling portalEnergy (input) against PSM tokens (output) and return amount received (output)
 691 |     |     /// @dev This function allows the caller to simulate a portalEnergy sell order of any size
 692 |     |     /// @dev Can only be called when the LP is active to avoid bad output and to prevent exchange
 693 |     |     /// @dev Update the token reserves to get the exchange price
 694 |     |     /// @param _amountInputPE The amount of Portal Energy sold
 695 |     |     /// @return amountReceived The amount of PSM tokens received by the recipient
 696 |     |     function quoteSellPortalEnergy(
 697 |     |         uint256 _amountInputPE
 698 |     |     ) public view activeLP returns (uint256 amountReceived) {
 699 |     |         /// @dev Calculate the PSM token reserve (output)
 700 |     |         uint256 reserve0 = IERC20(PSM_ADDRESS).balanceOf(VIRTUAL_LP) -
 701 |     |             virtualLP.fundingRewardPool();
 702 |     | 
 703 |     |         /// @dev Calculate the reserve of portalEnergy (input)
 704 |     |         /// @dev Avoid zero value to prevent theoretical drainer attack by donating PSM before selling 1 PE
 705 |     |         uint256 reserve1 = (reserve0 > CONSTANT_PRODUCT)
 706 |     |             ? 1
 707 |     |             : CONSTANT_PRODUCT / reserve0;
 708 |     | 
 709 |     |         /// @dev Calculate the amount of PSM tokens received based on the amount of portalEnergy sold
 710 |     |         amountReceived =
 711 |     |             (_amountInputPE * reserve0) /
 712 |     |             (_amountInputPE + reserve1);
 713 |     |     }
 714 |     | 
 715 |     |     // ============================================
 716 |     |     // ==           GENERAL FUNCTIONS            ==
 717 |     |     // ============================================
 718 |     |     /// @notice Concatenates two strings and returns the result string
 719 |     |     /// @dev This is a helper function to concatenate two strings into one
 720 |     |     /// @dev Used for automatic token naming
 721 | *   |     function concatenate(
 722 |     |         string memory a,
 723 |     |         string memory b
 724 |     |     ) internal pure returns (string memory) {
 725 |     |         return string(abi.encodePacked(a, b));
 726 |     |     }
 727 |     | 
 728 |     |     /// @notice Deploy the Portal Energy Token of this Portal
 729 |     |     /// @dev This function deploys the PortalEnergyToken of this Portal with the Portal as owner
 730 |     |     /// @dev Can only be called once
 731 |     |     function create_portalEnergyToken() external {
 732 |     |         if (portalEnergyTokenCreated) {
 733 |     |             revert TokenExists();
 734 |     |         }
 735 |     | 
 736 |     |         /// @dev Update the token creation flag to prevent future calls.
 737 |     |         portalEnergyTokenCreated = true;
 738 |     | 
 739 |     |         /// @dev Build the token name and symbol based on the principal token of this Portal.
 740 |     |         string memory name = concatenate("PE-", PRINCIPAL_NAME);
 741 |     | 
 742 |     |         string memory symbol = concatenate("PE-", PRINCIPAL_SYMBOL);
 743 |     | 
 744 |     |         /// @dev Deploy the token and update the related storage variable so that other functions can work.
 745 |     |         portalEnergyToken = new MintBurnToken(name, symbol);
 746 |     |     }
 747 |     | 
 748 |     |     /// @notice Users can burn their PortalEnergyTokens to increase portalEnergy of a recipient
 749 |     |     /// @dev This function allows users to burn PortalEnergyTokens for internal portalEnergy
 750 |     |     /// @dev Burn PortalEnergyTokens of caller and increase portalEnergy of the recipient
 751 |     |     /// @param _recipient The recipient of the portalEnergy increase
 752 |     |     /// @param _amount The amount of portalEnergyToken to burn
 753 |     |     function burnPortalEnergyToken(
 754 |     |         address _recipient,
 755 |     |         uint256 _amount
 756 |     |     ) external {
 757 |     |         /// @dev Check for zero value inputs
 758 |     |         if (_amount == 0) {
 759 |     |             revert InvalidAmount();
 760 |     |         }
 761 |     |         if (_recipient == address(0)) {
 762 |     |             revert InvalidAddress();
 763 |     |         }
 764 |     | 
 765 |     |         /// @dev Increase the portalEnergy of the recipient by the amount of portalEnergyToken burned
 766 |     |         accounts[_recipient].portalEnergy += _amount;
 767 |     | 
 768 |     |         /// @dev Burn portalEnergyToken from the caller's wallet
 769 |     |         portalEnergyToken.burnFrom(msg.sender, _amount);
 770 |     | 
 771 |     |         /// @dev Emit the event that the ERC20 representation has been burned and value accrued to recipient
 772 |     |         emit PortalEnergyBurned(msg.sender, _recipient, _amount);
 773 |     |     }
 774 |     | 
 775 |     |     /// @notice Users can mint portalEnergyToken to a recipient address using their internal balance
 776 |     |     /// @dev This function controls the minting of PortalEnergyToken
 777 |     |     /// @dev Decrease portalEnergy of caller and mint PortalEnergyTokens to the recipient
 778 |     |     /// @dev Contract must be owner of the PortalEnergyToken
 779 |     |     /// @param _recipient The recipient of the portalEnergyToken
 780 |     |     /// @param _amount The amount of portalEnergyToken to mint
 781 | *   |     function mintPortalEnergyToken(
 782 |     |         address _recipient,
 783 |     |         uint256 _amount
 784 |     |     ) external {
 785 |     |         /// @dev Check for zero value inputs
 786 | *   |         if (_amount == 0) {
 787 |     |             revert InvalidAmount();
 788 |     |         }
 789 | *   |         if (_recipient == address(0)) {
 790 |     |             revert InvalidAddress();
 791 |     |         }
 792 |     | 
 793 |     |         /// @dev Get the current state of the user stake
 794 | *   |         (
 795 |     |             ,
 796 |     |             ,
 797 | *   |             uint256 stakedBalance,
 798 | *   |             uint256 maxStakeDebt,
 799 | *   |             uint256 portalEnergy,
 800 |     |             ,
 801 |     | 
 802 | *   |         ) = getUpdateAccount(msg.sender, 0, true);
 803 |     | 
 804 |     |         /// @dev Check that the caller has sufficient portalEnergy to mint the amount of portalEnergyToken
 805 | *   |         if (portalEnergy < _amount) {
 806 | *   |             revert InsufficientBalance();
 807 |     |         }
 808 |     | 
 809 |     |         /// @dev Reduce the portalEnergy of the caller by the amount of minted tokens
 810 |     |         portalEnergy -= _amount;
 811 |     | 
 812 |     |         /// @dev Update the user stake struct
 813 |     |         _updateAccount(msg.sender, stakedBalance, maxStakeDebt, portalEnergy);
 814 |     | 
 815 |     |         /// @dev Mint portal energy tokens to the recipient's wallet
 816 |     |         portalEnergyToken.mint(_recipient, _amount);
 817 |     | 
 818 |     |         /// @dev Emit the event that the ERC20 representation has been minted to recipient
 819 |     |         emit PortalEnergyMinted(msg.sender, _recipient, _amount);
 820 |     |     }
 821 |     | 
 822 |     |     /// @notice Update the maximum lock duration up to the terminal value
 823 |     |     /// @dev Update the maximum lock duration up to the terminal value
 824 |     |     function updateMaxLockDuration() external {
 825 |     |         /// @dev Require that the lock duration can be updated
 826 |     |         if (lockDurationUpdateable == false) {
 827 |     |             revert DurationLocked();
 828 |     |         }
 829 |     | 
 830 |     |         /// @dev Calculate new lock duration
 831 |     |         uint256 newValue = 2 * (block.timestamp - CREATION_TIME);
 832 |     | 
 833 |     |         /// @dev Require that the new value will be larger than the existing value
 834 |     |         if (newValue <= maxLockDuration) {
 835 |     |             revert DurationTooLow();
 836 |     |         }
 837 |     | 
 838 |     |         if (newValue >= TERMINAL_MAX_LOCK_DURATION) {
 839 |     |             maxLockDuration = TERMINAL_MAX_LOCK_DURATION;
 840 |     |             lockDurationUpdateable = false;
 841 |     |         } else if (newValue > maxLockDuration) {
 842 |     |             maxLockDuration = newValue;
 843 |     |         }
 844 |     |     }
 845 |     | }
 846 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/VirtualLP.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-only
   2 |     | pragma solidity =0.8.19;
   3 |     | 
   4 |     | import {MintBurnToken} from "./MintBurnToken.sol";
   5 |     | import {IWater} from "./interfaces/IWater.sol";
   6 |     | import {ISingleStaking} from "./interfaces/ISingleStaking.sol";
   7 |     | import {IDualStaking} from "./interfaces/IDualStaking.sol";
   8 |     | import {IPortalV2MultiAsset} from "./interfaces/IPortalV2MultiAsset.sol";
   9 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  10 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  11 |     | import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  12 |     | import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
  13 |     | 
  14 |     | interface IWETH {
  15 |     |     function withdrawTo(address _account, uint256 _amount) external;
  16 |     | }
  17 |     | 
  18 |     | // ============================================
  19 |     | // ==              CUSTOM ERRORS             ==
  20 |     | // ============================================
  21 |     | error InactiveLP();
  22 |     | error ActiveLP();
  23 |     | error NotOwner();
  24 |     | error PortalNotRegistered();
  25 |     | error OwnerNotExpired();
  26 |     | error InsufficientReceived();
  27 |     | error InvalidConstructor();
  28 |     | error InvalidAddress();
  29 |     | error InvalidAmount();
  30 |     | error DeadlineExpired();
  31 |     | error FailedToSendNativeToken();
  32 |     | error FundingPhaseOngoing();
  33 |     | error FundingInsufficient();
  34 |     | error TokenExists();
  35 |     | error TimeLockActive();
  36 |     | error NoProfit();
  37 |     | error OwnerRevoked();
  38 |     | 
  39 |     | /// @title Portal V2 Virtual LP
  40 |     | /// @author Possum Labs
  41 |     | /** @notice This contract serves as the shared, virtual LP for multiple Portals
  42 |     |  * Each Portal must be registered by the owner
  43 |     |  * The contract is owned for a predetermined duration to enable registering more Portals
  44 |     |  * Registering more Portals must be permissioned because it can be malicious
  45 |     |  * Portals cannot be removed from the registry to guarantee Portal integrity
  46 |     |  * The full amount of PSM inside the LP is available to provide upfront yield for each Portal
  47 |     |  * Capital staked through the connected Portals is redirected and staked in an external yield source
  48 |     |  * The LP is refilled by convert() calls which exchanges ERC20 balances for PSM
  49 |     |  */
  50 |     | /// @dev Setup Process: 1. Deploy VirtualLP, 2. Deploy Portals, 3. Register Portals in VirtualLP 4. Activate LP
  51 | *   | contract VirtualLP is ReentrancyGuard {
  52 |     |     constructor(
  53 |     |         address _owner,
  54 |     |         uint256 _AMOUNT_TO_CONVERT,
  55 |     |         uint256 _FUNDING_PHASE_DURATION,
  56 |     |         uint256 _FUNDING_MIN_AMOUNT
  57 |     |     ) {
  58 |     |         if (_owner == address(0)) {
  59 |     |             revert InvalidConstructor();
  60 |     |         }
  61 |     |         if (_AMOUNT_TO_CONVERT == 0) {
  62 |     |             revert InvalidConstructor();
  63 |     |         }
  64 |     |         if (
  65 |     |             _FUNDING_PHASE_DURATION < 259200 ||
  66 |     |             _FUNDING_PHASE_DURATION > 2592000
  67 |     |         ) {
  68 |     |             revert InvalidConstructor();
  69 |     |         }
  70 |     |         if (_FUNDING_MIN_AMOUNT == 0) {
  71 |     |             revert InvalidConstructor();
  72 |     |         }
  73 |     | 
  74 |     |         AMOUNT_TO_CONVERT = _AMOUNT_TO_CONVERT;
  75 |     |         FUNDING_PHASE_DURATION = _FUNDING_PHASE_DURATION;
  76 |     |         FUNDING_MIN_AMOUNT = _FUNDING_MIN_AMOUNT;
  77 |     | 
  78 |     |         owner = _owner;
  79 |     |         OWNER_EXPIRY_TIME = OWNER_DURATION + block.timestamp;
  80 |     | 
  81 |     |         CREATION_TIME = block.timestamp;
  82 |     |     }
  83 |     | 
  84 |     |     // ============================================
  85 |     |     // ==            GLOBAL VARIABLES            ==
  86 |     |     // ============================================
  87 |     |     using SafeERC20 for IERC20;
  88 |     | 
  89 |     |     MintBurnToken public bToken; // the receipt token for funding the LP
  90 |     |     address public bTokenAddress; // the address of the receipt token
  91 |     | 
  92 |     |     uint256 constant SECONDS_PER_YEAR = 31536000; // seconds in a 365 day year
  93 |     |     uint256 constant MAX_UINT =
  94 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  95 |     | 
  96 |     |     address public owner;
  97 |     |     uint256 private constant OWNER_DURATION = 31536000; // 1 Year
  98 |     |     uint256 public immutable OWNER_EXPIRY_TIME; // Time required to pass before owner can be revoked
  99 |     |     uint256 public immutable AMOUNT_TO_CONVERT; // fixed amount of PSM tokens required to withdraw yield in the contract
 100 |     |     uint256 public immutable FUNDING_PHASE_DURATION; // seconds after deployment before Portal can be activated
 101 |     |     uint256 public immutable FUNDING_MIN_AMOUNT; // minimum funding required before Portal can be activated
 102 |     |     uint256 public immutable CREATION_TIME; // time stamp of deployment
 103 |     | 
 104 |     |     uint256 public constant FUNDING_APR = 36; // annual redemption value increase (APR) of bTokens
 105 |     |     uint256 public constant FUNDING_MAX_RETURN_PERCENT = 1000; // maximum redemption value percent of bTokens (must be >100)
 106 |     |     uint256 public constant FUNDING_REWARD_SHARE = 10; // 10% of yield goes to the funding pool until investors are paid back
 107 |     | 
 108 |     |     address constant WETH_ADDRESS = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
 109 |     |     address constant PSM_ADDRESS = 0x17A8541B82BF67e10B0874284b4Ae66858cb1fd5; // address of PSM token
 110 |     | 
 111 |     |     address public constant SINGLE_STAKING =
 112 |     |         0x314223E2fA375F972E159002Eb72A96301E99e22;
 113 |     |     address public constant DUAL_STAKING =
 114 |     |         0x31Fa38A6381e9d1f4770C73AB14a0ced1528A65E;
 115 |     |     address public constant esVKA = 0x95b3F9797077DDCa971aB8524b439553a220EB2A;
 116 |     | 
 117 | *   |     bool public isActiveLP; // Will be set to true when funding phase ends
 118 |     |     bool public bTokenCreated; // flag for bToken deployment
 119 |     |     uint256 public fundingBalance; // sum of all PSM funding contributions
 120 | *   |     uint256 public fundingRewardPool; // amount of PSM available for redemption against bTokens
 121 |     | 
 122 | *   |     mapping(address portal => bool isRegistered) public registeredPortals;
 123 |     |     mapping(address portal => mapping(address asset => address vault))
 124 |     |         public vaults;
 125 |     |     mapping(address portal => mapping(address asset => uint256 pid))
 126 |     |         public poolID;
 127 |     | 
 128 |     |     // ============================================
 129 |     |     // ==                EVENTS                  ==
 130 |     |     // ============================================
 131 |     |     event LP_Activated(address indexed, uint256 fundingBalance);
 132 |     |     event ConvertExecuted(
 133 |     |         address indexed token,
 134 |     |         address indexed caller,
 135 |     |         address indexed recipient,
 136 |     |         uint256 amount
 137 |     |     );
 138 |     | 
 139 |     |     event FundingReceived(address indexed, uint256 amount);
 140 |     |     event FundingWithdrawn(address indexed, uint256 amount);
 141 |     |     event RewardsRedeemed(
 142 |     |         address indexed,
 143 |     |         uint256 amountBurned,
 144 |     |         uint256 amountReceived
 145 |     |     );
 146 |     | 
 147 |     |     event RewardsClaimed(address indexed portal, uint256 timeStamp);
 148 |     | 
 149 |     |     // ============================================
 150 |     |     // ==               MODIFIERS                ==
 151 |     |     // ============================================
 152 |     |     modifier activeLP() {
 153 |     |         if (!isActiveLP) {
 154 |     |             revert InactiveLP();
 155 |     |         }
 156 |     |         _;
 157 |     |     }
 158 |     | 
 159 |     |     modifier inactiveLP() {
 160 |     |         if (isActiveLP) {
 161 |     |             revert ActiveLP();
 162 |     |         }
 163 |     |         _;
 164 |     |     }
 165 |     | 
 166 |     |     modifier registeredPortal() {
 167 |     |         if (!registeredPortals[msg.sender]) {
 168 |     |             revert PortalNotRegistered();
 169 |     |         }
 170 |     |         _;
 171 |     |     }
 172 |     | 
 173 |     |     modifier onlyOwner() {
 174 |     |         if (msg.sender != owner) {
 175 |     |             revert NotOwner();
 176 |     |         }
 177 |     |         _;
 178 |     |     }
 179 |     | 
 180 |     |     // ============================================
 181 |     |     // ==             LP FUNCTIONS               ==
 182 |     |     // ============================================
 183 |     |     /// @notice This function transfers PSM to a recipient address
 184 |     |     /// @dev Transfer an amount of PSM to a recipient
 185 |     |     /// @dev Can only be called by a registered address (Portal)
 186 |     |     /// @dev All critical logic is handled by the Portal, hence no additional checks
 187 |     |     /// @param _recipient The address that recieves the PSM
 188 |     |     /// @param _amount The amount of PSM send to the recipient
 189 |     |     function PSM_sendToPortalUser(
 190 |     |         address _recipient,
 191 |     |         uint256 _amount
 192 |     |     ) external registeredPortal {
 193 |     |         /// @dev Transfer PSM to the recipient
 194 |     |         IERC20(PSM_ADDRESS).transfer(_recipient, _amount);
 195 |     |     }
 196 |     | 
 197 |     |     /// @notice Function to add new Portals to the registry
 198 |     |     /// @dev Add new Portals to the registry. Portals can only be added, never removed
 199 |     |     /// @dev Only callable by owner to prevent malicious interactions
 200 |     |     /// @dev Function can override existing registries to fix potential integration errors
 201 |     |     /// @param _portal The address of the Portal to register
 202 |     |     /// @param _asset The address of the principal token of the Portal
 203 |     |     /// @param _vault The address of the staking Vault used by the Portal in the external protocol
 204 |     |     /// @param _pid The pool identifier of the staking Vault, relevant for the SingleStaking contract
 205 |     |     function registerPortal(
 206 |     |         address _portal,
 207 |     |         address _asset,
 208 |     |         address _vault,
 209 |     |         uint256 _pid
 210 |     |     ) external onlyOwner {
 211 |     |         ///@dev register Portal so that it can call protected functions
 212 |     |         registeredPortals[_portal] = true;
 213 |     | 
 214 |     |         /// @dev update the Portal asset mappings
 215 |     |         vaults[_portal][_asset] = _vault;
 216 |     |         poolID[_portal][_asset] = _pid;
 217 |     |     }
 218 |     | 
 219 |     |     /// @notice This function disables the ownership access
 220 |     |     /// @dev Set the zero address as owner
 221 |     |     /// @dev Callable by anyone after duration passed
 222 |     |     function removeOwner() external {
 223 |     |         if (block.timestamp < OWNER_EXPIRY_TIME) {
 224 |     |             revert OwnerNotExpired();
 225 |     |         }
 226 |     |         if (owner == address(0)) {
 227 |     |             revert OwnerRevoked();
 228 |     |         }
 229 |     | 
 230 |     |         owner = address(0);
 231 |     |     }
 232 |     | 
 233 |     |     // ============================================
 234 |     |     // ==      EXTERNAL PROTOCOL INTEGRATION     ==
 235 |     |     // ============================================
 236 |     |     /// @notice Deposit principal into the yield source
 237 |     |     /// @dev This function deposits principal tokens from a connected Portal into the external protocol
 238 |     |     /// @dev Receive and transfer tokens from the Portal to the external protocol via interface
 239 |     |     /// @param _asset The address of the asset to deposit
 240 |     |     /// @param _amount The amount of asset to deposit
 241 |     |     function depositToYieldSource(
 242 |     |         address _asset,
 243 |     |         uint256 _amount
 244 |     |     ) external registeredPortal {
 245 |     |         /// @dev Check that the withdraw timeLock is zero to protect stakers from griefing attack
 246 |     |         if (IWater(vaults[msg.sender][_asset]).lockTime() > 0) {
 247 |     |             revert TimeLockActive();
 248 |     |         }
 249 |     | 
 250 |     |         /// @dev Deposit tokens into Vault to receive Shares (WATER)
 251 |     |         /// @dev Approval of token spending is handled with a separate function to save gas
 252 |     |         uint256 depositShares = IWater(vaults[msg.sender][_asset]).deposit(
 253 |     |             _amount,
 254 |     |             address(this)
 255 |     |         );
 256 |     | 
 257 |     |         /// @dev Stake the Vault Shares into the staking contract using the pool identifier (pid)
 258 |     |         /// @dev Approval of token spending is handled with a separate function to save gas
 259 |     |         ISingleStaking(SINGLE_STAKING).deposit(
 260 |     |             poolID[msg.sender][_asset],
 261 |     |             depositShares
 262 |     |         );
 263 |     |     }
 264 |     | 
 265 |     |     /// @notice Withdraw principal from the yield source to the user
 266 |     |     /// @dev This function withdraws principal tokens from the external protocol
 267 |     |     /// @dev Transfer the tokens from the external protocol to a Portal user via integration interface
 268 |     |     /// @param _asset The address of the asset to withdraw
 269 |     |     /// @param _user The address of the user that will receive the withdrawn assets
 270 |     |     /// @param _amount The amount of assets to withdraw
 271 |     |     function withdrawFromYieldSource(
 272 |     |         address _asset,
 273 |     |         address _user,
 274 |     |         uint256 _amount
 275 |     |     ) external registeredPortal {
 276 |     |         /// @dev Calculate number of Vault Shares that equal the withdraw amount
 277 |     |         uint256 withdrawShares = IWater(vaults[msg.sender][_asset])
 278 |     |             .convertToShares(_amount);
 279 |     | 
 280 |     |         /// @dev Get the withdrawable assets from burning Vault Shares (consider rounding)
 281 |     |         uint256 withdrawAssets = IWater(vaults[msg.sender][_asset])
 282 |     |             .convertToAssets(withdrawShares);
 283 |     | 
 284 |     |         /// @dev Initialize helper variables for withdraw amount sanity check
 285 |     |         uint256 balanceBefore;
 286 |     |         uint256 balanceAfter;
 287 |     | 
 288 |     |         /// @dev Withdraw Vault Shares from Single Staking Contract
 289 |     |         ISingleStaking(SINGLE_STAKING).withdraw(
 290 |     |             poolID[msg.sender][_asset],
 291 |     |             withdrawShares
 292 |     |         );
 293 |     | 
 294 |     |         /// @dev Check if handling ETH, withdraw as WETH
 295 |     |         address tokenAdr = (_asset == address(0)) ? WETH_ADDRESS : _asset;
 296 |     | 
 297 |     |         /// @dev Withdraw the staked assets from Vault
 298 |     |         balanceBefore = IERC20(tokenAdr).balanceOf(address(this));
 299 |     |         IWater(vaults[msg.sender][_asset]).withdraw(
 300 |     |             withdrawAssets,
 301 |     |             address(this),
 302 |     |             address(this)
 303 |     |         );
 304 |     |         balanceAfter = IERC20(tokenAdr).balanceOf(address(this));
 305 |     | 
 306 |     |         /// @dev Sanity check on obtained amount from Vault
 307 |     |         _amount = balanceAfter - balanceBefore;
 308 |     | 
 309 |     |         /// @dev Transfer the obtained assets to the user
 310 |     |         /// @dev Convert WETH to ETH before sending
 311 |     |         if (_asset == address(0)) {
 312 |     |             IWETH(WETH_ADDRESS).withdrawTo(_user, _amount);
 313 |     |         } else {
 314 |     |             IERC20(tokenAdr).safeTransfer(_user, _amount);
 315 |     |         }
 316 |     |     }
 317 |     | 
 318 |     |     /// @notice Claim pending esVKA and USDC rewards, then restake esVKA
 319 |     |     /// @dev Claim protocol rewards for a specific Portal and restake esVKA
 320 |     |     /// @param _portal The address of a registered Portal
 321 |     |     function claimProtocolRewards(address _portal) external {
 322 |     |         /// @dev Get the asset of the Portal
 323 |     |         address asset = IPortalV2MultiAsset(_portal).PRINCIPAL_TOKEN_ADDRESS();
 324 |     | 
 325 |     |         /// @dev Claim esVKA rewards from staking the Vault Shares
 326 |     |         ISingleStaking(SINGLE_STAKING).deposit(poolID[_portal][asset], 0);
 327 |     | 
 328 |     |         uint256 esVKABalance = IERC20(esVKA).balanceOf(address(this));
 329 |     | 
 330 |     |         /// @dev Stake esVKA into the Dual Staking contract
 331 |     |         /// @dev Approval of token spending is handled with a separate function to save gas
 332 |     |         if (esVKABalance > 0) {
 333 |     |             IDualStaking(DUAL_STAKING).stake(esVKABalance, esVKA);
 334 |     |         }
 335 |     | 
 336 |     |         /// @dev Claim esVKA and USDC from DualStaking, stake the esVKA reward and receive USDC to contract
 337 |     |         IDualStaking(DUAL_STAKING).compound();
 338 |     | 
 339 |     |         /// @dev Emit the event that rewards have been claimed
 340 |     |         emit RewardsClaimed(_portal, block.timestamp);
 341 |     |     }
 342 |     | 
 343 |     |     /// @notice Internal function to get Vault profit before withdrawal fees
 344 |     |     /// @dev Get the surplus assets in the Vault excluding withdrawal fee
 345 |     |     /// @param _portal The address of a registered Portal
 346 |     |     function _getProfitOfPortal(
 347 |     |         address _portal
 348 |     |     ) private view returns (uint256 profitAsset, uint256 profitShares) {
 349 |     |         /// @dev Get the asset of the Portal
 350 |     |         IPortalV2MultiAsset portal = IPortalV2MultiAsset(_portal);
 351 |     |         address asset = portal.PRINCIPAL_TOKEN_ADDRESS();
 352 |     | 
 353 |     |         /// @dev Get the Vault shares owned by Portal
 354 |     |         uint256 sharesOwned = ISingleStaking(SINGLE_STAKING).getUserAmount(
 355 |     |             poolID[_portal][asset],
 356 |     |             address(this)
 357 |     |         );
 358 |     | 
 359 |     |         /// @dev Calculate the shares to be reserved for user withdrawals
 360 |     |         uint256 sharesDebt = IWater(vaults[_portal][asset]).convertToShares(
 361 |     |             portal.totalPrincipalStaked()
 362 |     |         );
 363 |     | 
 364 |     |         /// @dev Calculate the surplus shares owned by the Portal
 365 |     |         profitShares = (sharesOwned > sharesDebt)
 366 |     |             ? sharesOwned - sharesDebt
 367 |     |             : 0;
 368 |     | 
 369 |     |         /// @dev Calculate the net profit in assets
 370 |     |         profitAsset = IWater(vaults[_portal][asset]).convertToAssets(
 371 |     |             profitShares
 372 |     |         );
 373 |     |     }
 374 |     | 
 375 |     |     /// @notice View current net profit of a Vault used by a specific Portal
 376 |     |     /// @dev Get surplus assets in the Vault after deducting withdrawal fees
 377 |     |     /// @param _portal The address of a registered Portal
 378 |     |     function getProfitOfPortal(
 379 |     |         address _portal
 380 |     |     ) external view returns (uint256 profitOfPortal) {
 381 |     |         /// @dev Get the asset of the Portal
 382 |     |         address asset = IPortalV2MultiAsset(_portal).PRINCIPAL_TOKEN_ADDRESS();
 383 |     | 
 384 |     |         /// @dev Get the gross profit of the Vault
 385 |     |         (uint256 profit, ) = _getProfitOfPortal(_portal);
 386 |     | 
 387 |     |         /// @dev Calculate the net profit after withdrawal fees
 388 |     |         uint256 denominator = IWater(vaults[_portal][asset]).DENOMINATOR();
 389 |     |         uint256 withdrawalFee = IWater(vaults[_portal][asset]).withdrawalFees();
 390 |     | 
 391 |     |         profitOfPortal = (profit * (denominator - withdrawalFee)) / denominator;
 392 |     |     }
 393 |     | 
 394 |     |     /// @notice Withdraw the asset surplus of a Vault used by a specific Portal
 395 |     |     /// @dev Withdraw the asset surplus from Vault to contract
 396 |     |     /// @param _portal The address of a registered Portal
 397 |     |     function collectProfitOfPortal(address _portal) public {
 398 |     |         /// @dev Get the asset of the Portal
 399 |     |         address asset = IPortalV2MultiAsset(_portal).PRINCIPAL_TOKEN_ADDRESS();
 400 |     | 
 401 |     |         (uint256 profit, uint256 shares) = _getProfitOfPortal(_portal);
 402 |     | 
 403 |     |         /// @dev Check if there is profit to withdraw
 404 |     |         if (profit == 0 || shares == 0) {
 405 |     |             revert NoProfit();
 406 |     |         }
 407 |     | 
 408 |     |         /// @dev Withdraw the surplus Vault Shares from Single Staking Contract
 409 |     |         ISingleStaking(SINGLE_STAKING).withdraw(poolID[_portal][asset], shares);
 410 |     | 
 411 |     |         /// @dev Withdraw the profit Assets from the Vault to contract (collect WETH from ETH Vault)
 412 |     |         IWater(vaults[_portal][asset]).withdraw(
 413 |     |             profit,
 414 |     |             address(this),
 415 |     |             address(this)
 416 |     |         );
 417 |     |     }
 418 |     | 
 419 |     |     /// @notice Read the pending USDC protocol rewards earned by the LP contract
 420 |     |     /// @dev Get current USDC rewards pending from protocol fees
 421 |     |     function getPendingRewardsUSDC() external view returns (uint256 rewards) {
 422 |     |         rewards = IDualStaking(DUAL_STAKING).pendingRewardsUSDC(address(this));
 423 |     |     }
 424 |     | 
 425 |     |     /// @notice Read the timelock value of a Vault used by a specific Portal
 426 |     |     /// @dev Get the timelock of a Vault used by a Portal
 427 |     |     /// @param _portal The address of a registered Portal
 428 |     |     function getPortalVaultLockTime(
 429 |     |         address _portal
 430 |     |     ) external view returns (uint256 lockTime) {
 431 |     |         /// @dev Get the asset of the Portal
 432 |     |         IPortalV2MultiAsset portal = IPortalV2MultiAsset(_portal);
 433 |     |         address asset = portal.PRINCIPAL_TOKEN_ADDRESS();
 434 |     | 
 435 |     |         lockTime = IWater(vaults[_portal][asset]).lockTime();
 436 |     |     }
 437 |     | 
 438 |     |     /// @notice This function allows to update the Boost Multiplier to earn more esVKA
 439 |     |     /// @dev Update the Boost Multiplier of a Vault used by a specific Portal
 440 |     |     /// @param _portal The address of a registered Portal
 441 |     |     function updatePortalBoostMultiplier(address _portal) public {
 442 |     |         /// @dev Get the asset of the Portal
 443 |     |         IPortalV2MultiAsset portal = IPortalV2MultiAsset(_portal);
 444 |     |         address asset = portal.PRINCIPAL_TOKEN_ADDRESS();
 445 |     | 
 446 |     |         ISingleStaking(SINGLE_STAKING).updateBoostMultiplier(
 447 |     |             address(this),
 448 |     |             poolID[_portal][asset]
 449 |     |         );
 450 |     |     }
 451 |     | 
 452 |     |     /// @notice This function increases spending allowance for staking assets by Vaults
 453 |     |     /// @dev Increase the token spending allowance of assets by a staking Vault of a specific Portal
 454 |     |     /// @param _portal The address of a registered Portal
 455 |     |     function increaseAllowanceVault(address _portal) public {
 456 |     |         /// @dev Get the asset of the Portal
 457 |     |         address asset = IPortalV2MultiAsset(_portal).PRINCIPAL_TOKEN_ADDRESS();
 458 |     | 
 459 |     |         /// @dev Get the principal token address, WETH for ETH
 460 |     |         address tokenAdr = (asset == address(0)) ? WETH_ADDRESS : asset;
 461 |     | 
 462 |     |         /// @dev For ERC20 that require allowance to be 0 before increasing (e.g. USDT) add the following:
 463 |     |         /// IERC20(tokenAdr).approve(vaults[_portal][asset], 0);
 464 |     | 
 465 |     |         /// @dev Allow spending of Assets by the associated Vault
 466 |     |         IERC20(tokenAdr).safeIncreaseAllowance(
 467 |     |             vaults[_portal][asset],
 468 |     |             MAX_UINT
 469 |     |         );
 470 |     |     }
 471 |     | 
 472 |     |     /// @notice This function increases spending allowance for Vault Shares by the SingleStaking contract
 473 |     |     /// @dev Increase the token spending allowance of Vault Shares by the Single Staking contract
 474 |     |     /// @param _portal The address of a registered Portal
 475 |     |     function increaseAllowanceSingleStaking(address _portal) public {
 476 |     |         /// @dev Get the asset of the Portal
 477 |     |         address asset = IPortalV2MultiAsset(_portal).PRINCIPAL_TOKEN_ADDRESS();
 478 |     | 
 479 |     |         /// @dev Allow spending of Vault Shares of a Portal by the single staking contract
 480 |     |         IERC20(vaults[_portal][asset]).safeIncreaseAllowance(
 481 |     |             SINGLE_STAKING,
 482 |     |             MAX_UINT
 483 |     |         );
 484 |     |     }
 485 |     | 
 486 |     |     /// @notice This function increases spending allowance for esVKA by the DualStaking contract
 487 |     |     /// @dev Increase the token spending allowance of esVKA by the DualStaking contract
 488 |     |     function increaseAllowanceDualStaking() public {
 489 |     |         IERC20(esVKA).safeIncreaseAllowance(DUAL_STAKING, MAX_UINT);
 490 |     |     }
 491 |     | 
 492 |     |     // ============================================
 493 |     |     // ==              PSM CONVERTER             ==
 494 |     |     // ============================================
 495 |     |     /// @notice Handle the arbitrage conversion of tokens inside the contract for PSM tokens
 496 |     |     /// @dev This function handles the conversion of tokens inside the contract for PSM tokens
 497 |     |     /// @dev Collect rewards for funders and reallocate reward overflow to the LP (indirect)
 498 |     |     /// @dev Transfer the input (PSM) token from the caller to the contract
 499 |     |     /// @dev Transfer the specified output token from the contract to the caller
 500 |     |     /// @param _token The token to be obtained by the recipient
 501 |     |     /// @param _minReceived The minimum amount of tokens received
 502 |     |     function convert(
 503 |     |         address _token,
 504 |     |         address _recipient,
 505 |     |         uint256 _minReceived,
 506 |     |         uint256 _deadline
 507 |     |     ) external nonReentrant activeLP {
 508 |     |         /// @dev Check the validity of token and recipient addresses
 509 |     |         if (_token == PSM_ADDRESS || _recipient == address(0)) {
 510 |     |             revert InvalidAddress();
 511 |     |         }
 512 |     | 
 513 |     |         /// @dev Prevent zero value
 514 |     |         if (_minReceived == 0) {
 515 |     |             revert InvalidAmount();
 516 |     |         }
 517 |     | 
 518 |     |         /// @dev Check that the deadline has not expired
 519 |     |         if (_deadline < block.timestamp) {
 520 |     |             revert DeadlineExpired();
 521 |     |         }
 522 |     | 
 523 |     |         /// @dev Get the contract balance of the specified token
 524 |     |         uint256 contractBalance;
 525 |     |         if (_token == address(0)) {
 526 |     |             contractBalance = address(this).balance;
 527 |     |         } else {
 528 |     |             contractBalance = IERC20(_token).balanceOf(address(this));
 529 |     |         }
 530 |     | 
 531 |     |         /// @dev Check that enough output tokens are available for frontrun protection
 532 |     |         if (contractBalance < _minReceived) {
 533 |     |             revert InsufficientReceived();
 534 |     |         }
 535 |     | 
 536 |     |         /// @dev initialize helper variables
 537 |     |         uint256 maxRewards = bToken.totalSupply();
 538 |     |         uint256 newRewards = (AMOUNT_TO_CONVERT * FUNDING_REWARD_SHARE) / 100;
 539 |     | 
 540 |     |         /// @dev Check if rewards must be added, adjust reward pool accordingly
 541 |     |         if (fundingRewardPool + newRewards >= maxRewards) {
 542 |     |             fundingRewardPool = maxRewards;
 543 |     |         } else {
 544 |     |             fundingRewardPool += newRewards;
 545 |     |         }
 546 |     | 
 547 |     |         /// @dev transfer PSM to the LP
 548 |     |         IERC20(PSM_ADDRESS).transferFrom(
 549 |     |             msg.sender,
 550 |     |             address(this),
 551 |     |             AMOUNT_TO_CONVERT
 552 |     |         );
 553 |     | 
 554 |     |         /// @dev Transfer the output token from the contract to the recipient
 555 |     |         if (_token == address(0)) {
 556 |     |             (bool sent, ) = payable(_recipient).call{value: contractBalance}(
 557 |     |                 ""
 558 |     |             );
 559 |     |             if (!sent) {
 560 |     |                 revert FailedToSendNativeToken();
 561 |     |             }
 562 |     |         } else {
 563 |     |             IERC20(_token).safeTransfer(_recipient, contractBalance);
 564 |     |         }
 565 |     | 
 566 |     |         emit ConvertExecuted(_token, msg.sender, _recipient, contractBalance);
 567 |     |     }
 568 |     | 
 569 |     |     // ============================================
 570 |     |     // ==                FUNDING                 ==
 571 |     |     // ============================================
 572 |     |     /// @notice End the funding phase and enable normal contract functionality
 573 |     |     /// @dev This function activates the Virtual LP
 574 |     |     /// @dev Can only be called when the Virtual LP is inactive
 575 |     |     function activateLP() external inactiveLP {
 576 |     |         /// @dev Check that the funding phase is over and enough funding has been contributed
 577 |     |         if (block.timestamp < CREATION_TIME + FUNDING_PHASE_DURATION) {
 578 |     |             revert FundingPhaseOngoing();
 579 |     |         }
 580 |     |         if (fundingBalance < FUNDING_MIN_AMOUNT) {
 581 |     |             revert FundingInsufficient();
 582 |     |         }
 583 |     | 
 584 |     |         /// @dev Activate the Virtual LP
 585 |     |         isActiveLP = true;
 586 |     | 
 587 |     |         /// @dev Emit the activation event with the address of the contract and the funding balance
 588 |     |         emit LP_Activated(address(this), fundingBalance);
 589 |     |     }
 590 |     | 
 591 |     |     /// @notice Allow users to deposit PSM to fund the Virtual LP
 592 |     |     /// @dev This function allows users to deposit PSM tokens during the funding phase
 593 |     |     /// @dev The bToken must have been deployed via the contract in advance
 594 |     |     /// @dev Increase the fundingBalance tracker by the amount of PSM deposited
 595 |     |     /// @dev Transfer the PSM tokens from the user to the contract
 596 |     |     /// @dev Mint bTokens to the user
 597 |     |     /// @param _amount The amount of PSM to deposit
 598 |     |     function contributeFunding(uint256 _amount) external inactiveLP {
 599 |     |         /// @dev Prevent zero amount transaction
 600 |     |         if (_amount == 0) {
 601 |     |             revert InvalidAmount();
 602 |     |         }
 603 |     | 
 604 |     |         /// @dev Calculate the amount of bTokens to be minted based on the maximum return
 605 |     |         uint256 mintableAmount = (_amount * FUNDING_MAX_RETURN_PERCENT) / 100;
 606 |     | 
 607 |     |         /// @dev Increase the funding tracker balance by the amount of PSM deposited
 608 |     |         fundingBalance += _amount;
 609 |     | 
 610 |     |         /// @dev Transfer the PSM tokens from the user to the contract
 611 |     |         IERC20(PSM_ADDRESS).transferFrom(msg.sender, address(this), _amount);
 612 |     | 
 613 |     |         /// @dev Mint bTokens to the user
 614 |     |         bToken.mint(msg.sender, mintableAmount);
 615 |     | 
 616 |     |         /// @dev Emit the FundingReceived event with the user address and the mintable amount
 617 |     |         emit FundingReceived(msg.sender, mintableAmount);
 618 |     |     }
 619 |     | 
 620 |     |     /// @notice Allow users to burn bTokens to recover PSM funding before the Virtual LP is activated
 621 |     |     /// @dev This function allows users to burn bTokens during the funding phase of the contract to get back PSM
 622 |     |     /// @dev The bToken must have been deployed via the contract in advance
 623 |     |     /// @dev Decrease the fundingBalance tracker by the amount of PSM withdrawn
 624 |     |     /// @dev Burn the appropriate amount of bTokens from the caller
 625 |     |     /// @dev Transfer the PSM tokens from the contract to the caller
 626 |     |     /// @param _amountBtoken The amount of bTokens burned to withdraw PSM
 627 |     |     function withdrawFunding(uint256 _amountBtoken) external inactiveLP {
 628 |     |         /// @dev Prevent zero amount transaction
 629 |     |         if (_amountBtoken == 0) {
 630 |     |             revert InvalidAmount();
 631 |     |         }
 632 |     | 
 633 |     |         /// @dev Calculate the amount of PSM returned to the user
 634 |     |         uint256 withdrawAmount = (_amountBtoken * 100) /
 635 |     |             FUNDING_MAX_RETURN_PERCENT;
 636 |     | 
 637 |     |         /// @dev Decrease the fundingBalance tracker by the amount of PSM withdrawn
 638 |     |         fundingBalance -= withdrawAmount;
 639 |     | 
 640 |     |         /// @dev Burn bTokens from the user
 641 |     |         bToken.burnFrom(msg.sender, _amountBtoken);
 642 |     | 
 643 |     |         /// @dev Transfer the PSM tokens from the contract to the user
 644 |     |         IERC20(PSM_ADDRESS).transfer(msg.sender, withdrawAmount);
 645 |     | 
 646 |     |         /// @dev Emit an event that the user has withdrawn an amount of funding
 647 |     |         emit FundingWithdrawn(msg.sender, withdrawAmount);
 648 |     |     }
 649 |     | 
 650 |     |     /// @notice Calculate the current burn value of bTokens
 651 |     |     /// @dev Get the current burn value of any amount of bTokens
 652 |     |     /// @param _amount The amount of bTokens to burn
 653 |     |     /// @return burnValue The amount of PSM received when redeeming bTokens
 654 |     |     function getBurnValuePSM(
 655 |     |         uint256 _amount
 656 |     |     ) public view activeLP returns (uint256 burnValue) {
 657 |     |         /// @dev Calculate the minimum burn value
 658 |     |         uint256 minValue = (_amount * 100) / FUNDING_MAX_RETURN_PERCENT;
 659 |     | 
 660 |     |         /// @dev Calculate the time based burn value
 661 |     |         uint256 accruedValue = (_amount *
 662 |     |             (block.timestamp - CREATION_TIME) *
 663 |     |             FUNDING_APR) / (100 * SECONDS_PER_YEAR);
 664 |     | 
 665 |     |         /// @dev Calculate the maximum and current burn value
 666 |     |         uint256 maxValue = _amount;
 667 |     |         uint256 currentValue = minValue + accruedValue;
 668 |     | 
 669 |     |         burnValue = (currentValue < maxValue) ? currentValue : maxValue;
 670 |     |     }
 671 |     | 
 672 |     |     /// @notice Get the amount of bTokens that can be burned against the reward Pool
 673 |     |     /// @dev Calculate how many bTokens can be burned to redeem the entire reward Pool
 674 |     |     /// @return amountBurnable The amount of bTokens that can be redeemed for rewards
 675 |     |     function getBurnableBtokenAmount()
 676 |     |         public
 677 |     |         view
 678 |     |         activeLP
 679 |     |         returns (uint256 amountBurnable)
 680 |     |     {
 681 |     |         /// @dev Calculate the burn value of 1 full bToken in PSM
 682 |     |         /// @dev Add 1 WEI to handle rounding issue in the next step
 683 |     |         uint256 burnValueFullToken = getBurnValuePSM(1e18) + 1;
 684 |     | 
 685 |     |         /// @dev Calculate and return the amount of bTokens burnable
 686 |     |         /// @dev This will slightly underestimate because of the 1 WEI for reliability reasons
 687 |     |         amountBurnable = (fundingRewardPool * 1e18) / burnValueFullToken;
 688 |     |     }
 689 |     | 
 690 |     |     /// @notice This function allows users to redeem bTokens for PSM tokens
 691 |     |     /// @dev Burn bTokens to receive PSM when the Portal is active
 692 |     |     /// @dev Reduce the funding reward pool by the amount of PSM payable to the user
 693 |     |     /// @dev Burn the bTokens from the user wallet
 694 |     |     /// @dev Transfer the PSM tokens to the user
 695 |     |     /// @param _amount The amount of bTokens to burn
 696 |     |     function burnBtokens(uint256 _amount) external {
 697 |     |         /// @dev Check that the burn amount is not zero
 698 |     |         if (_amount == 0) {
 699 |     |             revert InvalidAmount();
 700 |     |         }
 701 |     | 
 702 |     |         /// @dev Check that the burn amount is not larger than what can be redeemed
 703 |     |         uint256 burnable = getBurnableBtokenAmount();
 704 |     |         if (_amount > burnable) {
 705 |     |             revert InvalidAmount();
 706 |     |         }
 707 |     | 
 708 |     |         /// @dev Calculate how many PSM the user receives based on the burn amount
 709 |     |         uint256 amountToReceive = getBurnValuePSM(_amount);
 710 |     | 
 711 |     |         /// @dev Reduce the funding reward pool by the amount of PSM payable to the user
 712 |     |         fundingRewardPool -= amountToReceive;
 713 |     | 
 714 |     |         /// @dev Burn the bTokens from the user's balance
 715 |     |         bToken.burnFrom(msg.sender, _amount);
 716 |     | 
 717 |     |         /// @dev Transfer the PSM to the user
 718 |     |         IERC20(PSM_ADDRESS).transfer(msg.sender, amountToReceive);
 719 |     | 
 720 |     |         /// @dev Event that informs about burn amount and received PSM by the caller
 721 |     |         emit RewardsRedeemed(msg.sender, _amount, amountToReceive);
 722 |     |     }
 723 |     | 
 724 |     |     // ============================================
 725 |     |     // ==           GENERAL FUNCTIONS            ==
 726 |     |     // ============================================
 727 |     |     /// @notice Deploy the bToken of the Virtual LP
 728 |     |     /// @dev This function deploys the bToken of this contract and takes ownership
 729 |     |     /// @dev Must be called before the Virtual LP is activated
 730 |     |     /// @dev Can only be called once
 731 |     |     function create_bToken() external inactiveLP {
 732 |     |         if (bTokenCreated) {
 733 |     |             revert TokenExists();
 734 |     |         }
 735 |     | 
 736 |     |         /// @dev Update the token creation flag to prevent future calls.
 737 |     |         bTokenCreated = true;
 738 |     | 
 739 |     |         /// @dev Set the token name and symbol
 740 |     |         string memory name = "bVaultkaLending";
 741 |     |         string memory symbol = "bVKA-L";
 742 |     | 
 743 |     |         /// @dev Deploy the token and update the related storage variable so that other functions can work.
 744 |     |         bToken = new MintBurnToken(name, symbol);
 745 |     |         bTokenAddress = address(bToken);
 746 |     |     }
 747 |     | 
 748 |     |     receive() external payable {}
 749 |     | 
 750 |     |     fallback() external payable {}
 751 |     | }
 752 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/interfaces/IDualStaking.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity =0.8.19;
  3 |     | 
  4 |     | interface IDualStaking {
  5 |     |     // enter address of esVKA or VKA
  6 |     |     function stake(uint256 amount, address token) external;
  7 |     | 
  8 |     |     /// @notice function to claim protocol fee and re stake the esVKA rewards
  9 |     |     function compound() external;
 10 |     | 
 11 |     |     function pendingRewardsUSDC(address account) external view returns (uint);
 12 |     | }
 13 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/interfaces/IPortalV2MultiAsset.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity =0.8.19;
  3 |     | 
  4 |     | interface IPortalV2MultiAsset {
  5 |     |     function totalPrincipalStaked()
  6 |     |         external
  7 |     |         view
  8 |     |         returns (uint256 totalPrincipalStaked);
  9 |     | 
 10 |     |     function PRINCIPAL_TOKEN_ADDRESS()
 11 |     |         external
 12 |     |         view
 13 |     |         returns (address PRINCIPAL_TOKEN_ADDRESS);
 14 |     | 
 15 |     |     function maxLockDuration() external view returns (uint256);
 16 |     | }
 17 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/interfaces/ISingleStaking.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity =0.8.19;
  3 |     | 
  4 |     | interface ISingleStaking {
  5 |     |     function deposit(uint256 _pid, uint256 _amount) external;
  6 |     | 
  7 |     |     function withdraw(uint256 _pid, uint256 _amount) external;
  8 |     | 
  9 |     |     function claimAll() external;
 10 |     | 
 11 |     |     function getPoolTokenAddress(uint256 _pid) external view returns (address);
 12 |     | 
 13 |     |     function poolLength() external view returns (uint256);
 14 |     | 
 15 |     |     function getUserAmount(
 16 |     |         uint256 _pid,
 17 |     |         address _user
 18 |     |     ) external view returns (uint256);
 19 |     | 
 20 |     |     function updateBoostMultiplier(
 21 |     |         address _user,
 22 |     |         uint256 _pid
 23 |     |     ) external returns (uint256 _newMultiplier);
 24 |     | }
 25 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/interfaces/IUSDC.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | // !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.6.6. SEE SOURCE BELOW. !!
   3 |     | pragma solidity >=0.7.0 <0.9.0;
   4 |     | 
   5 |     | interface IUSDC {
   6 |     |     event Approval(
   7 |     |         address indexed owner,
   8 |     |         address indexed spender,
   9 |     |         uint256 value
  10 |     |     );
  11 |     |     event AuthorizationCanceled(
  12 |     |         address indexed authorizer,
  13 |     |         bytes32 indexed nonce
  14 |     |     );
  15 |     |     event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);
  16 |     |     event Blacklisted(address indexed _account);
  17 |     |     event BlacklisterChanged(address indexed newBlacklister);
  18 |     |     event Burn(address indexed burner, uint256 amount);
  19 |     |     event MasterMinterChanged(address indexed newMasterMinter);
  20 |     |     event Mint(address indexed minter, address indexed to, uint256 amount);
  21 |     |     event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);
  22 |     |     event MinterRemoved(address indexed oldMinter);
  23 |     |     event OwnershipTransferred(address previousOwner, address newOwner);
  24 |     |     event Pause();
  25 |     |     event PauserChanged(address indexed newAddress);
  26 |     |     event RescuerChanged(address indexed newRescuer);
  27 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  28 |     |     event UnBlacklisted(address indexed _account);
  29 |     |     event Unpause();
  30 |     | 
  31 |     |     function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);
  32 |     | 
  33 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
  34 |     | 
  35 |     |     function PERMIT_TYPEHASH() external view returns (bytes32);
  36 |     | 
  37 |     |     function RECEIVE_WITH_AUTHORIZATION_TYPEHASH()
  38 |     |         external
  39 |     |         view
  40 |     |         returns (bytes32);
  41 |     | 
  42 |     |     function TRANSFER_WITH_AUTHORIZATION_TYPEHASH()
  43 |     |         external
  44 |     |         view
  45 |     |         returns (bytes32);
  46 |     | 
  47 |     |     function allowance(address owner, address spender)
  48 |     |         external
  49 |     |         view
  50 |     |         returns (uint256);
  51 |     | 
  52 |     |     function approve(address spender, uint256 value) external returns (bool);
  53 |     | 
  54 |     |     function authorizationState(address authorizer, bytes32 nonce)
  55 |     |         external
  56 |     |         view
  57 |     |         returns (bool);
  58 |     | 
  59 |     |     function balanceOf(address account) external view returns (uint256);
  60 |     | 
  61 |     |     function blacklist(address _account) external;
  62 |     | 
  63 |     |     function blacklister() external view returns (address);
  64 |     | 
  65 |     |     function burn(uint256 _amount) external;
  66 |     | 
  67 |     |     function cancelAuthorization(
  68 |     |         address authorizer,
  69 |     |         bytes32 nonce,
  70 |     |         uint8 v,
  71 |     |         bytes32 r,
  72 |     |         bytes32 s
  73 |     |     ) external;
  74 |     | 
  75 |     |     function configureMinter(address minter, uint256 minterAllowedAmount)
  76 |     |         external
  77 |     |         returns (bool);
  78 |     | 
  79 |     |     function currency() external view returns (string memory);
  80 |     | 
  81 |     |     function decimals() external view returns (uint8);
  82 |     | 
  83 |     |     function decreaseAllowance(address spender, uint256 decrement)
  84 |     |         external
  85 |     |         returns (bool);
  86 |     | 
  87 |     |     function increaseAllowance(address spender, uint256 increment)
  88 |     |         external
  89 |     |         returns (bool);
  90 |     | 
  91 |     |     function initialize(
  92 |     |         string memory tokenName,
  93 |     |         string memory tokenSymbol,
  94 |     |         string memory tokenCurrency,
  95 |     |         uint8 tokenDecimals,
  96 |     |         address newMasterMinter,
  97 |     |         address newPauser,
  98 |     |         address newBlacklister,
  99 |     |         address newOwner
 100 |     |     ) external;
 101 |     | 
 102 |     |     function initializeV2(string memory newName) external;
 103 |     | 
 104 |     |     function initializeV2_1(address lostAndFound) external;
 105 |     | 
 106 |     |     function isBlacklisted(address _account) external view returns (bool);
 107 |     | 
 108 |     |     function isMinter(address account) external view returns (bool);
 109 |     | 
 110 |     |     function masterMinter() external view returns (address);
 111 |     | 
 112 |     |     function mint(address _to, uint256 _amount) external returns (bool);
 113 |     | 
 114 |     |     function minterAllowance(address minter) external view returns (uint256);
 115 |     | 
 116 |     |     function name() external view returns (string memory);
 117 |     | 
 118 |     |     function nonces(address owner) external view returns (uint256);
 119 |     | 
 120 |     |     function owner() external view returns (address);
 121 |     | 
 122 |     |     function pause() external;
 123 |     | 
 124 |     |     function paused() external view returns (bool);
 125 |     | 
 126 |     |     function pauser() external view returns (address);
 127 |     | 
 128 |     |     function permit(
 129 |     |         address owner,
 130 |     |         address spender,
 131 |     |         uint256 value,
 132 |     |         uint256 deadline,
 133 |     |         uint8 v,
 134 |     |         bytes32 r,
 135 |     |         bytes32 s
 136 |     |     ) external;
 137 |     | 
 138 |     |     function receiveWithAuthorization(
 139 |     |         address from,
 140 |     |         address to,
 141 |     |         uint256 value,
 142 |     |         uint256 validAfter,
 143 |     |         uint256 validBefore,
 144 |     |         bytes32 nonce,
 145 |     |         uint8 v,
 146 |     |         bytes32 r,
 147 |     |         bytes32 s
 148 |     |     ) external;
 149 |     | 
 150 |     |     function removeMinter(address minter) external returns (bool);
 151 |     | 
 152 |     |     function rescueERC20(
 153 |     |         address tokenContract,
 154 |     |         address to,
 155 |     |         uint256 amount
 156 |     |     ) external;
 157 |     | 
 158 |     |     function rescuer() external view returns (address);
 159 |     | 
 160 |     |     function symbol() external view returns (string memory);
 161 |     | 
 162 |     |     function totalSupply() external view returns (uint256);
 163 |     | 
 164 |     |     function transfer(address to, uint256 value) external returns (bool);
 165 |     | 
 166 |     |     function transferFrom(
 167 |     |         address from,
 168 |     |         address to,
 169 |     |         uint256 value
 170 |     |     ) external returns (bool);
 171 |     | 
 172 |     |     function transferOwnership(address newOwner) external;
 173 |     | 
 174 |     |     function transferWithAuthorization(
 175 |     |         address from,
 176 |     |         address to,
 177 |     |         uint256 value,
 178 |     |         uint256 validAfter,
 179 |     |         uint256 validBefore,
 180 |     |         bytes32 nonce,
 181 |     |         uint8 v,
 182 |     |         bytes32 r,
 183 |     |         bytes32 s
 184 |     |     ) external;
 185 |     | 
 186 |     |     function unBlacklist(address _account) external;
 187 |     | 
 188 |     |     function unpause() external;
 189 |     | 
 190 |     |     function updateBlacklister(address _newBlacklister) external;
 191 |     | 
 192 |     |     function updateMasterMinter(address _newMasterMinter) external;
 193 |     | 
 194 |     |     function updatePauser(address _newPauser) external;
 195 |     | 
 196 |     |     function updateRescuer(address newRescuer) external;
 197 |     | 
 198 |     |     function version() external view returns (string memory);
 199 |     | }
 200 |     | 
 201 |     | // THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
 202 |     | /*
 203 |     | [{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"authorizer","type":"address"},{"indexed":true,"internalType":"bytes32","name":"nonce","type":"bytes32"}],"name":"AuthorizationCanceled","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"authorizer","type":"address"},{"indexed":true,"internalType":"bytes32","name":"nonce","type":"bytes32"}],"name":"AuthorizationUsed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_account","type":"address"}],"name":"Blacklisted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newBlacklister","type":"address"}],"name":"BlacklisterChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"burner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Burn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newMasterMinter","type":"address"}],"name":"MasterMinterChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"minter","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Mint","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"minter","type":"address"},{"indexed":false,"internalType":"uint256","name":"minterAllowedAmount","type":"uint256"}],"name":"MinterConfigured","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"oldMinter","type":"address"}],"name":"MinterRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":false,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[],"name":"Pause","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newAddress","type":"address"}],"name":"PauserChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newRescuer","type":"address"}],"name":"RescuerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_account","type":"address"}],"name":"UnBlacklisted","type":"event"},{"anonymous":false,"inputs":[],"name":"Unpause","type":"event"},{"inputs":[],"name":"CANCEL_AUTHORIZATION_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PERMIT_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"RECEIVE_WITH_AUTHORIZATION_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"TRANSFER_WITH_AUTHORIZATION_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"authorizer","type":"address"},{"internalType":"bytes32","name":"nonce","type":"bytes32"}],"name":"authorizationState","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_account","type":"address"}],"name":"blacklist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"blacklister","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"authorizer","type":"address"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"cancelAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"minter","type":"address"},{"internalType":"uint256","name":"minterAllowedAmount","type":"uint256"}],"name":"configureMinter","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"currency","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"decrement","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"increment","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"tokenName","type":"string"},{"internalType":"string","name":"tokenSymbol","type":"string"},{"internalType":"string","name":"tokenCurrency","type":"string"},{"internalType":"uint8","name":"tokenDecimals","type":"uint8"},{"internalType":"address","name":"newMasterMinter","type":"address"},{"internalType":"address","name":"newPauser","type":"address"},{"internalType":"address","name":"newBlacklister","type":"address"},{"internalType":"address","name":"newOwner","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"newName","type":"string"}],"name":"initializeV2","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"lostAndFound","type":"address"}],"name":"initializeV2_1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_account","type":"address"}],"name":"isBlacklisted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isMinter","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"masterMinter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"minter","type":"address"}],"name":"minterAllowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"validAfter","type":"uint256"},{"internalType":"uint256","name":"validBefore","type":"uint256"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"receiveWithAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"minter","type":"address"}],"name":"removeMinter","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IERC20","name":"tokenContract","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"rescueERC20","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"rescuer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"validAfter","type":"uint256"},{"internalType":"uint256","name":"validBefore","type":"uint256"},{"internalType":"bytes32","name":"nonce","type":"bytes32"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"transferWithAuthorization","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_account","type":"address"}],"name":"unBlacklist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newBlacklister","type":"address"}],"name":"updateBlacklister","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newMasterMinter","type":"address"}],"name":"updateMasterMinter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newPauser","type":"address"}],"name":"updatePauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newRescuer","type":"address"}],"name":"updateRescuer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}]
 204 |     | */
 205 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/interfaces/IVirtualLP.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity =0.8.19;
  3 |     | 
  4 |     | interface IVirtualLP {
  5 |     |     function PSM_sendToPortalUser(address _recipient, uint256 _amount) external;
  6 |     | 
  7 |     |     function depositToYieldSource(address _asset, uint256 _amount) external;
  8 |     | 
  9 |     |     function withdrawFromYieldSource(
 10 |     |         address _asset,
 11 |     |         address _user,
 12 |     |         uint256 _amount
 13 |     |     ) external;
 14 |     | 
 15 |     |     function isActiveLP() external view returns (bool);
 16 |     | 
 17 |     |     function fundingRewardPool() external view returns (uint256);
 18 |     | }
 19 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/interfaces/IWater.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity =0.8.19;
  3 |     | 
  4 |     | interface IWater {
  5 |     |     function deposit(
  6 |     |         uint256 _assets,
  7 |     |         address _receiver
  8 |     |     ) external returns (uint256);
  9 |     | 
 10 |     |     function withdraw(
 11 |     |         uint256 _assets,
 12 |     |         address _receiver,
 13 |     |         address _owner
 14 |     |     ) external returns (uint256);
 15 |     | 
 16 |     |     function withdrawETH(uint256 _assets) external returns (uint256);
 17 |     | 
 18 |     |     function convertToShares(uint256 assets) external view returns (uint256);
 19 |     | 
 20 |     |     function convertToAssets(uint256 shares) external view returns (uint256);
 21 |     | 
 22 |     |     function lockTime() external view returns (uint256);
 23 |     | 
 24 |     |     function withdrawalFees() external view returns (uint256);
 25 |     | 
 26 |     |     function DENOMINATOR() external view returns (uint256);
 27 |     | }
 28 |     | 

/Users/secoalba/Documents/PROGRAMACION/BLOCKCHAIN_DEV/SOLIDITY/SECURITY/AUDIT/PRIVATE/Portals-local/src/V2MultiAsset/interfaces/IcEther.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | // !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.6.6. SEE SOURCE BELOW. !!
   3 |     | pragma solidity >=0.7.0 <0.9.0;
   4 |     | 
   5 |     | interface IcEther {
   6 |     |     function name() external view returns (string memory);
   7 |     | 
   8 |     |     function approve(address spender, uint256 amount) external returns (bool);
   9 |     | 
  10 |     |     function mint() external payable;
  11 |     | 
  12 |     |     function reserveFactorMantissa() external view returns (uint256);
  13 |     | 
  14 |     |     function borrowBalanceCurrent(address account) external returns (uint256);
  15 |     | 
  16 |     |     function totalSupply() external view returns (uint256);
  17 |     | 
  18 |     |     function exchangeRateStored() external view returns (uint256);
  19 |     | 
  20 |     |     function transferFrom(
  21 |     |         address src,
  22 |     |         address dst,
  23 |     |         uint256 amount
  24 |     |     ) external returns (bool);
  25 |     | 
  26 |     |     function pendingAdmin() external view returns (address);
  27 |     | 
  28 |     |     function decimals() external view returns (uint256);
  29 |     | 
  30 |     |     function balanceOfUnderlying(address owner) external returns (uint256);
  31 |     | 
  32 |     |     function getCash() external view returns (uint256);
  33 |     | 
  34 |     |     function _setComptroller(address newComptroller) external returns (uint256);
  35 |     | 
  36 |     |     function totalBorrows() external view returns (uint256);
  37 |     | 
  38 |     |     function repayBorrow() external payable;
  39 |     | 
  40 |     |     function comptroller() external view returns (address);
  41 |     | 
  42 |     |     function _reduceReserves(uint256 reduceAmount) external returns (uint256);
  43 |     | 
  44 |     |     function initialExchangeRateMantissa() external view returns (uint256);
  45 |     | 
  46 |     |     function accrualBlockNumber() external view returns (uint256);
  47 |     | 
  48 |     |     function balanceOf(address owner) external view returns (uint256);
  49 |     | 
  50 |     |     function totalBorrowsCurrent() external returns (uint256);
  51 |     | 
  52 |     |     function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
  53 |     | 
  54 |     |     function totalReserves() external view returns (uint256);
  55 |     | 
  56 |     |     function symbol() external view returns (string memory);
  57 |     | 
  58 |     |     function borrowBalanceStored(address account)
  59 |     |         external
  60 |     |         view
  61 |     |         returns (uint256);
  62 |     | 
  63 |     |     function accrueInterest() external returns (uint256);
  64 |     | 
  65 |     |     function transfer(address dst, uint256 amount) external returns (bool);
  66 |     | 
  67 |     |     function borrowIndex() external view returns (uint256);
  68 |     | 
  69 |     |     function liquidateBorrow(address borrower, address cTokenCollateral)
  70 |     |         external
  71 |     |         payable;
  72 |     | 
  73 |     |     function supplyRatePerBlock() external view returns (uint256);
  74 |     | 
  75 |     |     function seize(
  76 |     |         address liquidator,
  77 |     |         address borrower,
  78 |     |         uint256 seizeTokens
  79 |     |     ) external returns (uint256);
  80 |     | 
  81 |     |     function _setPendingAdmin(address newPendingAdmin)
  82 |     |         external
  83 |     |         returns (uint256);
  84 |     | 
  85 |     |     function exchangeRateCurrent() external returns (uint256);
  86 |     | 
  87 |     |     function getAccountSnapshot(address account)
  88 |     |         external
  89 |     |         view
  90 |     |         returns (
  91 |     |             uint256,
  92 |     |             uint256,
  93 |     |             uint256,
  94 |     |             uint256
  95 |     |         );
  96 |     | 
  97 |     |     function borrow(uint256 borrowAmount) external returns (uint256);
  98 |     | 
  99 |     |     function redeem(uint256 redeemTokens) external returns (uint256);
 100 |     | 
 101 |     |     function allowance(address owner, address spender)
 102 |     |         external
 103 |     |         view
 104 |     |         returns (uint256);
 105 |     | 
 106 |     |     function repayBorrowBehalf(address borrower) external payable;
 107 |     | 
 108 |     |     function _acceptAdmin() external returns (uint256);
 109 |     | 
 110 |     |     function _setInterestRateModel(address newInterestRateModel)
 111 |     |         external
 112 |     |         returns (uint256);
 113 |     | 
 114 |     |     function interestRateModel() external view returns (address);
 115 |     | 
 116 |     |     function admin() external view returns (address);
 117 |     | 
 118 |     |     function borrowRatePerBlock() external view returns (uint256);
 119 |     | 
 120 |     |     function _setReserveFactor(uint256 newReserveFactorMantissa)
 121 |     |         external
 122 |     |         returns (uint256);
 123 |     | 
 124 |     |     function isCToken() external view returns (bool);
 125 |     | 
 126 |     |     fallback() external payable;
 127 |     | 
 128 |     |     event AccrueInterest(
 129 |     |         uint256 interestAccumulated,
 130 |     |         uint256 borrowIndex,
 131 |     |         uint256 totalBorrows
 132 |     |     );
 133 |     |     event Mint(address minter, uint256 mintAmount, uint256 mintTokens);
 134 |     |     event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);
 135 |     |     event Borrow(
 136 |     |         address borrower,
 137 |     |         uint256 borrowAmount,
 138 |     |         uint256 accountBorrows,
 139 |     |         uint256 totalBorrows
 140 |     |     );
 141 |     |     event RepayBorrow(
 142 |     |         address payer,
 143 |     |         address borrower,
 144 |     |         uint256 repayAmount,
 145 |     |         uint256 accountBorrows,
 146 |     |         uint256 totalBorrows
 147 |     |     );
 148 |     |     event LiquidateBorrow(
 149 |     |         address liquidator,
 150 |     |         address borrower,
 151 |     |         uint256 repayAmount,
 152 |     |         address cTokenCollateral,
 153 |     |         uint256 seizeTokens
 154 |     |     );
 155 |     |     event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);
 156 |     |     event NewAdmin(address oldAdmin, address newAdmin);
 157 |     |     event NewComptroller(address oldComptroller, address newComptroller);
 158 |     |     event NewMarketInterestRateModel(
 159 |     |         address oldInterestRateModel,
 160 |     |         address newInterestRateModel
 161 |     |     );
 162 |     |     event NewReserveFactor(
 163 |     |         uint256 oldReserveFactorMantissa,
 164 |     |         uint256 newReserveFactorMantissa
 165 |     |     );
 166 |     |     event ReservesReduced(
 167 |     |         address admin,
 168 |     |         uint256 reduceAmount,
 169 |     |         uint256 newTotalReserves
 170 |     |     );
 171 |     |     event Failure(uint256 error, uint256 info, uint256 detail);
 172 |     |     event Transfer(address indexed from, address indexed to, uint256 amount);
 173 |     |     event Approval(
 174 |     |         address indexed owner,
 175 |     |         address indexed spender,
 176 |     |         uint256 amount
 177 |     |     );
 178 |     | }
 179 |     | 
 180 |     | // THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:
 181 |     | /*
 182 |     | [{"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"mint","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"reserveFactorMantissa","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"account","type":"address"}],"name":"borrowBalanceCurrent","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"exchangeRateStored","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"src","type":"address"},{"name":"dst","type":"address"},{"name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"pendingAdmin","outputs":[{"name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"owner","type":"address"}],"name":"balanceOfUnderlying","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getCash","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"newComptroller","type":"address"}],"name":"_setComptroller","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalBorrows","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"repayBorrow","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"comptroller","outputs":[{"name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"reduceAmount","type":"uint256"}],"name":"_reduceReserves","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"initialExchangeRateMantissa","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"accrualBlockNumber","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalBorrowsCurrent","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"redeemAmount","type":"uint256"}],"name":"redeemUnderlying","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalReserves","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"account","type":"address"}],"name":"borrowBalanceStored","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"accrueInterest","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"dst","type":"address"},{"name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"borrowIndex","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"borrower","type":"address"},{"name":"cTokenCollateral","type":"address"}],"name":"liquidateBorrow","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"supplyRatePerBlock","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"liquidator","type":"address"},{"name":"borrower","type":"address"},{"name":"seizeTokens","type":"uint256"}],"name":"seize","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"newPendingAdmin","type":"address"}],"name":"_setPendingAdmin","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"exchangeRateCurrent","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"account","type":"address"}],"name":"getAccountSnapshot","outputs":[{"name":"","type":"uint256"},{"name":"","type":"uint256"},{"name":"","type":"uint256"},{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"borrowAmount","type":"uint256"}],"name":"borrow","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"redeemTokens","type":"uint256"}],"name":"redeem","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"owner","type":"address"},{"name":"spender","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"borrower","type":"address"}],"name":"repayBorrowBehalf","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"_acceptAdmin","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"newInterestRateModel","type":"address"}],"name":"_setInterestRateModel","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"interestRateModel","outputs":[{"name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"admin","outputs":[{"name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"borrowRatePerBlock","outputs":[{"name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"newReserveFactorMantissa","type":"uint256"}],"name":"_setReserveFactor","outputs":[{"name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"isCToken","outputs":[{"name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"name":"comptroller_","type":"address"},{"name":"interestRateModel_","type":"address"},{"name":"initialExchangeRateMantissa_","type":"uint256"},{"name":"name_","type":"string"},{"name":"symbol_","type":"string"},{"name":"decimals_","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"stateMutability":"payable","type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"interestAccumulated","type":"uint256"},{"indexed":false,"name":"borrowIndex","type":"uint256"},{"indexed":false,"name":"totalBorrows","type":"uint256"}],"name":"AccrueInterest","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"minter","type":"address"},{"indexed":false,"name":"mintAmount","type":"uint256"},{"indexed":false,"name":"mintTokens","type":"uint256"}],"name":"Mint","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"redeemer","type":"address"},{"indexed":false,"name":"redeemAmount","type":"uint256"},{"indexed":false,"name":"redeemTokens","type":"uint256"}],"name":"Redeem","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"borrower","type":"address"},{"indexed":false,"name":"borrowAmount","type":"uint256"},{"indexed":false,"name":"accountBorrows","type":"uint256"},{"indexed":false,"name":"totalBorrows","type":"uint256"}],"name":"Borrow","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"payer","type":"address"},{"indexed":false,"name":"borrower","type":"address"},{"indexed":false,"name":"repayAmount","type":"uint256"},{"indexed":false,"name":"accountBorrows","type":"uint256"},{"indexed":false,"name":"totalBorrows","type":"uint256"}],"name":"RepayBorrow","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"liquidator","type":"address"},{"indexed":false,"name":"borrower","type":"address"},{"indexed":false,"name":"repayAmount","type":"uint256"},{"indexed":false,"name":"cTokenCollateral","type":"address"},{"indexed":false,"name":"seizeTokens","type":"uint256"}],"name":"LiquidateBorrow","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"oldPendingAdmin","type":"address"},{"indexed":false,"name":"newPendingAdmin","type":"address"}],"name":"NewPendingAdmin","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"oldAdmin","type":"address"},{"indexed":false,"name":"newAdmin","type":"address"}],"name":"NewAdmin","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"oldComptroller","type":"address"},{"indexed":false,"name":"newComptroller","type":"address"}],"name":"NewComptroller","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"oldInterestRateModel","type":"address"},{"indexed":false,"name":"newInterestRateModel","type":"address"}],"name":"NewMarketInterestRateModel","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"oldReserveFactorMantissa","type":"uint256"},{"indexed":false,"name":"newReserveFactorMantissa","type":"uint256"}],"name":"NewReserveFactor","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"admin","type":"address"},{"indexed":false,"name":"reduceAmount","type":"uint256"},{"indexed":false,"name":"newTotalReserves","type":"uint256"}],"name":"ReservesReduced","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"error","type":"uint256"},{"indexed":false,"name":"info","type":"uint256"},{"indexed":false,"name":"detail","type":"uint256"}],"name":"Failure","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"amount","type":"uint256"}],"name":"Approval","type":"event"}]
 183 |     | */
 184 |     | 

